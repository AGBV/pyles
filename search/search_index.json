{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Pyles Pyles is a python implementation of the Celes framework (based on Matlab ) and extends its functionality by providing optical parameters, similar to MSTM (based on Fortran ). As of 01.07.2022 The code will be documented as much as possible, to make it easier to use, fix, modify, and/or extend the current code base. Insted of using Sphinx , which kinda state of the art AFAIK , Pyles is documented using MkDocs , i.e., markdown. To simplify the generation of documentation, the plugin mkdocstrings is used to extract the documentation inside the code and present it in mkdocs . Currently the NumpyDoc style is used to document the code, which currently prohibts the use of mkgendocs , a nice tool to automatically generate a reference page. If someone has ideas to extend the documentation or its functionality, or objections on what or how something is currently written, please open up an issue so it can be dealt with :)","title":"Home"},{"location":"#welcome-to-pyles","text":"Pyles is a python implementation of the Celes framework (based on Matlab ) and extends its functionality by providing optical parameters, similar to MSTM (based on Fortran ).","title":"Welcome to Pyles"},{"location":"#as-of-01072022","text":"The code will be documented as much as possible, to make it easier to use, fix, modify, and/or extend the current code base. Insted of using Sphinx , which kinda state of the art AFAIK , Pyles is documented using MkDocs , i.e., markdown. To simplify the generation of documentation, the plugin mkdocstrings is used to extract the documentation inside the code and present it in mkdocs . Currently the NumpyDoc style is used to document the code, which currently prohibts the use of mkgendocs , a nice tool to automatically generate a reference page. If someone has ideas to extend the documentation or its functionality, or objections on what or how something is currently written, please open up an issue so it can be dealt with :)","title":"As of 01.07.2022"},{"location":"todo/","text":"TODO As of 01.07.2022. pyles only implements the celes functionality until the calculation of the scattering coefficients. These are needed for the new optics class to calculate parameters found in MSTM . Expanding the functionality of pyles and improving its code base will be tracked in the TODO list here. In the future, if needed, this will be presented more like a roadmap :) [ ] Create pages for the documentation [ ] Orient the created documentation around the Di\u00e1taxis framework [ ] Complete the documentation of the code","title":"TODO"},{"location":"todo/#todo","text":"As of 01.07.2022. pyles only implements the celes functionality until the calculation of the scattering coefficients. These are needed for the new optics class to calculate parameters found in MSTM . Expanding the functionality of pyles and improving its code base will be tracked in the TODO list here. In the future, if needed, this will be presented more like a roadmap :) [ ] Create pages for the documentation [ ] Orient the created documentation around the Di\u00e1taxis framework [ ] Complete the documentation of the code","title":"TODO"},{"location":"references/","text":"Reference Particles Initial Field Parameters Solver Numerics Simulation Optics","title":"Reference"},{"location":"references/#reference","text":"Particles Initial Field Parameters Solver Numerics Simulation Optics","title":"Reference"},{"location":"references/initial_field/","text":"InitialField ( beam_width , focal_point , field_type = 'gaussian' , amplitude = 1 , polar_angle = 0 , azimuthal_angle = 0 , polarization = 'TE' ) Source code in src/initial_field.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def __init__ ( self , beam_width , focal_point , field_type : str = 'gaussian' , amplitude : float = 1 , polar_angle : float = 0 , azimuthal_angle : float = 0 , polarization : str = 'TE' ): self . field_type = field_type self . amplitude = amplitude self . polar_angle = polar_angle self . azimuthal_angle = azimuthal_angle self . polarization = polarization self . beam_width = beam_width self . focal_point = focal_point self . log = logging . getLogger ( __name__ ) self . __setup () field_type = field_type instance-attribute amplitude = amplitude instance-attribute polar_angle = polar_angle instance-attribute azimuthal_angle = azimuthal_angle instance-attribute polarization = polarization instance-attribute beam_width = beam_width instance-attribute focal_point = focal_point instance-attribute log = logging . getLogger ( __name__ ) instance-attribute __set_pol_idx () Source code in src/initial_field.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def __set_pol_idx ( self ): if ( isinstance ( self . polarization , str ) and self . polarization . lower () == 'unp' ) or ( isinstance ( self . polarization , int ) and self . polarization == 0 ): # Unpolarized is also present in the MSTM output self . pol = 0 elif ( isinstance ( self . polarization , str ) and self . polarization . lower () == 'te' ) or ( isinstance ( self . polarization , int ) and self . polarization == 1 ): # Coresponds to the perpendicular value found in MSTM self . pol = 1 elif ( isinstance ( self . polarization , str ) and self . polarization . lower () == 'tm' ) or ( isinstance ( self . polarization , int ) and self . polarization == 2 ): # Coresponds to the parallel value found in MSTM self . pol = 2 else : self . pol = 0 self . log . warning ( ' {} is not a valid polarization type. Please use TE or TM. Reverting to unpolarized' . format ( self . polarization )) __set_normal_incidence () Source code in src/initial_field.py 39 40 def __set_normal_incidence ( self ): self . normal_incidence = np . abs ( np . sin ( self . polar_angle )) < 1e-5 __setup () Source code in src/initial_field.py 42 43 44 def __setup ( self ): self . __set_pol_idx () self . __set_normal_incidence ()","title":"Initial field"},{"location":"references/initial_field/#src.initial_field.InitialField","text":"Source code in src/initial_field.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def __init__ ( self , beam_width , focal_point , field_type : str = 'gaussian' , amplitude : float = 1 , polar_angle : float = 0 , azimuthal_angle : float = 0 , polarization : str = 'TE' ): self . field_type = field_type self . amplitude = amplitude self . polar_angle = polar_angle self . azimuthal_angle = azimuthal_angle self . polarization = polarization self . beam_width = beam_width self . focal_point = focal_point self . log = logging . getLogger ( __name__ ) self . __setup ()","title":"InitialField"},{"location":"references/initial_field/#src.initial_field.InitialField.field_type","text":"","title":"field_type"},{"location":"references/initial_field/#src.initial_field.InitialField.amplitude","text":"","title":"amplitude"},{"location":"references/initial_field/#src.initial_field.InitialField.polar_angle","text":"","title":"polar_angle"},{"location":"references/initial_field/#src.initial_field.InitialField.azimuthal_angle","text":"","title":"azimuthal_angle"},{"location":"references/initial_field/#src.initial_field.InitialField.polarization","text":"","title":"polarization"},{"location":"references/initial_field/#src.initial_field.InitialField.beam_width","text":"","title":"beam_width"},{"location":"references/initial_field/#src.initial_field.InitialField.focal_point","text":"","title":"focal_point"},{"location":"references/initial_field/#src.initial_field.InitialField.log","text":"","title":"log"},{"location":"references/initial_field/#src.initial_field.InitialField.__set_pol_idx","text":"Source code in src/initial_field.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def __set_pol_idx ( self ): if ( isinstance ( self . polarization , str ) and self . polarization . lower () == 'unp' ) or ( isinstance ( self . polarization , int ) and self . polarization == 0 ): # Unpolarized is also present in the MSTM output self . pol = 0 elif ( isinstance ( self . polarization , str ) and self . polarization . lower () == 'te' ) or ( isinstance ( self . polarization , int ) and self . polarization == 1 ): # Coresponds to the perpendicular value found in MSTM self . pol = 1 elif ( isinstance ( self . polarization , str ) and self . polarization . lower () == 'tm' ) or ( isinstance ( self . polarization , int ) and self . polarization == 2 ): # Coresponds to the parallel value found in MSTM self . pol = 2 else : self . pol = 0 self . log . warning ( ' {} is not a valid polarization type. Please use TE or TM. Reverting to unpolarized' . format ( self . polarization ))","title":"__set_pol_idx()"},{"location":"references/initial_field/#src.initial_field.InitialField.__set_normal_incidence","text":"Source code in src/initial_field.py 39 40 def __set_normal_incidence ( self ): self . normal_incidence = np . abs ( np . sin ( self . polar_angle )) < 1e-5","title":"__set_normal_incidence()"},{"location":"references/initial_field/#src.initial_field.InitialField.__setup","text":"Source code in src/initial_field.py 42 43 44 def __setup ( self ): self . __set_pol_idx () self . __set_normal_incidence ()","title":"__setup()"},{"location":"references/numerics/","text":"Numerics ( lmax , sampling_points_number = 100 , polar_angles = None , azimuthal_angles = None , gpu = False , particle_distance_resolution = 10.0 , solver = None ) Source code in src/numerics.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def __init__ ( self , lmax : int , sampling_points_number : Union [ int , np . ndarray ] = 100 , polar_angles : np . ndarray = None , azimuthal_angles : np . ndarray = None , gpu : bool = False , particle_distance_resolution = 10.0 , solver = None ): self . log = logging . getLogger ( __name__ ) self . lmax = lmax self . sampling_points_number = np . squeeze ( sampling_points_number ) if ( polar_angles is None ) or ( azimuthal_angles is None ): if self . sampling_points_number . size == 0 : self . sampling_points_number = np . array ([ 100 ]) self . log . warning ( 'Number of sampling points cant be an empty array. Reverting to 100 points (Fibonacci sphere).' ) elif self . sampling_points_number . size > 2 : self . sampling_points_number = np . array ( [ sampling_points_number [ 0 ]]) self . log . warning ( 'Number of sampling points with more than two dimensions is not supported. Reverting to the first element in the provided array (Fibonacci sphere).' ) if self . sampling_points_number . size == 1 : _ , polar_angles , azimuthal_angles = Numerics . compute_fibonacci_sphere_points ( sampling_points_number [ 0 ]) elif self . sampling_points_number . size == 2 : self . polar_angles_linspace = np . linspace ( 0 , np . pi , sampling_points_number [ 1 ]) self . azimuthal_angles_linspace = np . linspace ( 0 , 2 * np . pi , sampling_points_number [ 0 ] + 1 )[: - 1 ] polar_angles , azimuthal_angles = np . meshgrid ( self . polar_angles_linspace , self . azimuthal_angles_linspace , indexing = 'xy' ) polar_angles = polar_angles . ravel () azimuthal_angles = azimuthal_angles . ravel () else : self . sampling_points_number = None self . polar_angles = polar_angles self . azimuthal_angles = azimuthal_angles self . gpu = gpu self . particle_distance_resolution = particle_distance_resolution self . solver = solver if self . gpu : from numba import cuda if not cuda . is_available (): self . log . warning ( 'No supported GPU in numba detected! Falling back to the CPU implementation.' ) self . gpu = False self . __setup () log = logging . getLogger ( __name__ ) instance-attribute lmax = lmax instance-attribute sampling_points_number = np . squeeze ( sampling_points_number ) instance-attribute polar_angles_linspace = np . linspace ( 0 , np . pi , sampling_points_number [ 1 ]) instance-attribute azimuthal_angles_linspace = np . linspace ( 0 , 2 * np . pi , sampling_points_number [ 0 ] + 1 )[: - 1 ] instance-attribute polar_angles = polar_angles instance-attribute azimuthal_angles = azimuthal_angles instance-attribute gpu = gpu instance-attribute particle_distance_resolution = particle_distance_resolution instance-attribute solver = solver instance-attribute __compute_nmax () Source code in src/numerics.py 62 63 def __compute_nmax ( self ): self . nmax = 2 * self . lmax * ( self . lmax + 2 ) __plm_coefficients () Source code in src/numerics.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def __plm_coefficients ( self ): import sympy as sym self . plm_coeff_table = np . zeros (( 2 * self . lmax + 1 , 2 * self . lmax + 1 , self . lmax + 1 )) ct = sym . Symbol ( 'ct' ) st = sym . Symbol ( 'st' ) plm = legendre_normalized_trigon ( ct , y = st , lmax = 2 * self . lmax ) for l in range ( 2 * self . lmax + 1 ): for m in range ( l + 1 ): cf = sym . poly ( plm [ l , m ], ct , st ) . coeffs () self . plm_coeff_table [ l , m , 0 : len ( cf )] = cf __setup () Source code in src/numerics.py 82 83 def __setup ( self ): self . __compute_nmax () compute_plm_coefficients () Source code in src/numerics.py 87 88 def compute_plm_coefficients ( self ): self . __plm_coefficients () compute_translation_table () Source code in src/numerics.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 def compute_translation_table ( self ): self . log . info ( 'Computing the translation table' ) jmax = jmult_max ( 1 , self . lmax ) self . translation_ab5 = np . zeros ( ( jmax , jmax , 2 * self . lmax + 1 ), dtype = complex ) # No idea why or how this value for max_two_j works, # but got it through trial and error. # If you get any Wigner errors, change this value (e.g. 3*lmax) max_two_j = 2 * self . lmax + 3 wig . wig_table_init ( max_two_j , 3 ) wig . wig_temp_init ( max_two_j ) # Needs to be paralilized or the loop needs to be shortened! # Probably using one/two loop(s) and index using the lookup table. for tau1 in range ( 1 , 3 ): for l1 in range ( 1 , self . lmax + 1 ): for m1 in range ( - l1 , l1 + 1 ): j1 = multi2single_index ( 0 , tau1 , l1 , m1 , self . lmax ) for tau2 in range ( 1 , 3 ): for l2 in range ( 1 , self . lmax + 1 ): for m2 in range ( - l2 , l2 + 1 ): j2 = multi2single_index ( 0 , tau2 , l2 , m2 , self . lmax ) for p in range ( 0 , 2 * self . lmax + 1 ): if tau1 == tau2 : self . translation_ab5 [ j1 , j2 , p ] = np . power ( 1 j , abs ( m1 - m2 ) - abs ( m1 ) - abs ( m2 ) + l2 - l1 + p ) * np . power ( - 1.0 , m1 - m2 ) * \\ np . sqrt (( 2 * l1 + 1 ) * ( 2 * l2 + 1 ) / ( 2 * l1 * ( l1 + 1 ) * l2 * ( l2 + 1 ))) * \\ ( l1 * ( l1 + 1 ) + l2 * ( l2 + 1 ) - p * ( p + 1 )) * np . sqrt ( 2 * p + 1 ) * \\ wig . wig3jj_array ( 2 * np . array ([ l1 , l2 , p , m1 , - m2 , - m1 + m2 ])) * wig . wig3jj_array ( 2 * np . array ([ l1 , l2 , p , 0 , 0 , 0 ])) elif p > 0 : self . translation_ab5 [ j1 , j2 , p ] = np . power ( 1 j , abs ( m1 - m2 ) - abs ( m1 ) - abs ( m2 ) + l2 - l1 + p ) * np . power ( - 1.0 , m1 - m2 ) * \\ np . sqrt (( 2 * l1 + 1 ) * ( 2 * l2 + 1 ) / ( 2 * l1 * ( l1 + 1 ) * l2 * ( l2 + 1 ))) * \\ np . lib . scimath . sqrt (( l1 + l2 + 1 + p ) * ( l1 + l2 + 1 - p ) * ( p + l1 - l2 ) * ( p - l1 + l2 ) * ( 2 * p + 1 )) * \\ wig . wig3jj_array ( 2 * np . array ([ l1 , l2 , p , m1 , - m2 , - m1 + m2 ])) * wig . wig3jj_array ( 2 * np . array ([ l1 , l2 , p - 1 , 0 , 0 , 0 ])) wig . wig_table_free () wig . wig_temp_free () compute_fibonacci_sphere_points ( n = 100 ) staticmethod Source code in src/numerics.py 131 132 133 134 135 136 137 138 139 140 141 @staticmethod def compute_fibonacci_sphere_points ( n = 100 ): golden_ratio = ( 1 + 5 ** 0.5 ) / 2 i = np . arange ( 0 , n ) phi = 2 * np . pi * ( i / golden_ratio % 1 ) theta = np . arccos ( 1 - 2 * i / n ) return np . stack (( np . sin ( theta ) * np . cos ( phi ), np . sin ( theta ) * np . sin ( phi ), np . cos ( theta )), axis = 1 ), theta , phi compute_spherical_unity_vectors () Source code in src/numerics.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 def compute_spherical_unity_vectors ( self ): self . e_r = np . stack (( np . sin ( self . polar_angles ) * np . cos ( self . azimuthal_angles ), np . sin ( self . polar_angles ) * np . sin ( self . azimuthal_angles ), np . cos ( self . polar_angles )), axis = 1 ) self . e_theta = np . stack (( np . cos ( self . polar_angles ) * np . cos ( self . azimuthal_angles ), np . cos ( self . polar_angles ) * np . sin ( self . azimuthal_angles ), - np . sin ( self . polar_angles )), axis = 1 ) self . e_phi = np . stack (( - np . sin ( self . azimuthal_angles ), np . cos ( self . azimuthal_angles ), np . zeros_like ( self . azimuthal_angles )), axis = 1 )","title":"Numerics"},{"location":"references/numerics/#src.numerics.Numerics","text":"Source code in src/numerics.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def __init__ ( self , lmax : int , sampling_points_number : Union [ int , np . ndarray ] = 100 , polar_angles : np . ndarray = None , azimuthal_angles : np . ndarray = None , gpu : bool = False , particle_distance_resolution = 10.0 , solver = None ): self . log = logging . getLogger ( __name__ ) self . lmax = lmax self . sampling_points_number = np . squeeze ( sampling_points_number ) if ( polar_angles is None ) or ( azimuthal_angles is None ): if self . sampling_points_number . size == 0 : self . sampling_points_number = np . array ([ 100 ]) self . log . warning ( 'Number of sampling points cant be an empty array. Reverting to 100 points (Fibonacci sphere).' ) elif self . sampling_points_number . size > 2 : self . sampling_points_number = np . array ( [ sampling_points_number [ 0 ]]) self . log . warning ( 'Number of sampling points with more than two dimensions is not supported. Reverting to the first element in the provided array (Fibonacci sphere).' ) if self . sampling_points_number . size == 1 : _ , polar_angles , azimuthal_angles = Numerics . compute_fibonacci_sphere_points ( sampling_points_number [ 0 ]) elif self . sampling_points_number . size == 2 : self . polar_angles_linspace = np . linspace ( 0 , np . pi , sampling_points_number [ 1 ]) self . azimuthal_angles_linspace = np . linspace ( 0 , 2 * np . pi , sampling_points_number [ 0 ] + 1 )[: - 1 ] polar_angles , azimuthal_angles = np . meshgrid ( self . polar_angles_linspace , self . azimuthal_angles_linspace , indexing = 'xy' ) polar_angles = polar_angles . ravel () azimuthal_angles = azimuthal_angles . ravel () else : self . sampling_points_number = None self . polar_angles = polar_angles self . azimuthal_angles = azimuthal_angles self . gpu = gpu self . particle_distance_resolution = particle_distance_resolution self . solver = solver if self . gpu : from numba import cuda if not cuda . is_available (): self . log . warning ( 'No supported GPU in numba detected! Falling back to the CPU implementation.' ) self . gpu = False self . __setup ()","title":"Numerics"},{"location":"references/numerics/#src.numerics.Numerics.log","text":"","title":"log"},{"location":"references/numerics/#src.numerics.Numerics.lmax","text":"","title":"lmax"},{"location":"references/numerics/#src.numerics.Numerics.sampling_points_number","text":"","title":"sampling_points_number"},{"location":"references/numerics/#src.numerics.Numerics.polar_angles_linspace","text":"","title":"polar_angles_linspace"},{"location":"references/numerics/#src.numerics.Numerics.azimuthal_angles_linspace","text":"","title":"azimuthal_angles_linspace"},{"location":"references/numerics/#src.numerics.Numerics.polar_angles","text":"","title":"polar_angles"},{"location":"references/numerics/#src.numerics.Numerics.azimuthal_angles","text":"","title":"azimuthal_angles"},{"location":"references/numerics/#src.numerics.Numerics.gpu","text":"","title":"gpu"},{"location":"references/numerics/#src.numerics.Numerics.particle_distance_resolution","text":"","title":"particle_distance_resolution"},{"location":"references/numerics/#src.numerics.Numerics.solver","text":"","title":"solver"},{"location":"references/numerics/#src.numerics.Numerics.__compute_nmax","text":"Source code in src/numerics.py 62 63 def __compute_nmax ( self ): self . nmax = 2 * self . lmax * ( self . lmax + 2 )","title":"__compute_nmax()"},{"location":"references/numerics/#src.numerics.Numerics.__plm_coefficients","text":"Source code in src/numerics.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def __plm_coefficients ( self ): import sympy as sym self . plm_coeff_table = np . zeros (( 2 * self . lmax + 1 , 2 * self . lmax + 1 , self . lmax + 1 )) ct = sym . Symbol ( 'ct' ) st = sym . Symbol ( 'st' ) plm = legendre_normalized_trigon ( ct , y = st , lmax = 2 * self . lmax ) for l in range ( 2 * self . lmax + 1 ): for m in range ( l + 1 ): cf = sym . poly ( plm [ l , m ], ct , st ) . coeffs () self . plm_coeff_table [ l , m , 0 : len ( cf )] = cf","title":"__plm_coefficients()"},{"location":"references/numerics/#src.numerics.Numerics.__setup","text":"Source code in src/numerics.py 82 83 def __setup ( self ): self . __compute_nmax ()","title":"__setup()"},{"location":"references/numerics/#src.numerics.Numerics.compute_plm_coefficients","text":"Source code in src/numerics.py 87 88 def compute_plm_coefficients ( self ): self . __plm_coefficients ()","title":"compute_plm_coefficients()"},{"location":"references/numerics/#src.numerics.Numerics.compute_translation_table","text":"Source code in src/numerics.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 def compute_translation_table ( self ): self . log . info ( 'Computing the translation table' ) jmax = jmult_max ( 1 , self . lmax ) self . translation_ab5 = np . zeros ( ( jmax , jmax , 2 * self . lmax + 1 ), dtype = complex ) # No idea why or how this value for max_two_j works, # but got it through trial and error. # If you get any Wigner errors, change this value (e.g. 3*lmax) max_two_j = 2 * self . lmax + 3 wig . wig_table_init ( max_two_j , 3 ) wig . wig_temp_init ( max_two_j ) # Needs to be paralilized or the loop needs to be shortened! # Probably using one/two loop(s) and index using the lookup table. for tau1 in range ( 1 , 3 ): for l1 in range ( 1 , self . lmax + 1 ): for m1 in range ( - l1 , l1 + 1 ): j1 = multi2single_index ( 0 , tau1 , l1 , m1 , self . lmax ) for tau2 in range ( 1 , 3 ): for l2 in range ( 1 , self . lmax + 1 ): for m2 in range ( - l2 , l2 + 1 ): j2 = multi2single_index ( 0 , tau2 , l2 , m2 , self . lmax ) for p in range ( 0 , 2 * self . lmax + 1 ): if tau1 == tau2 : self . translation_ab5 [ j1 , j2 , p ] = np . power ( 1 j , abs ( m1 - m2 ) - abs ( m1 ) - abs ( m2 ) + l2 - l1 + p ) * np . power ( - 1.0 , m1 - m2 ) * \\ np . sqrt (( 2 * l1 + 1 ) * ( 2 * l2 + 1 ) / ( 2 * l1 * ( l1 + 1 ) * l2 * ( l2 + 1 ))) * \\ ( l1 * ( l1 + 1 ) + l2 * ( l2 + 1 ) - p * ( p + 1 )) * np . sqrt ( 2 * p + 1 ) * \\ wig . wig3jj_array ( 2 * np . array ([ l1 , l2 , p , m1 , - m2 , - m1 + m2 ])) * wig . wig3jj_array ( 2 * np . array ([ l1 , l2 , p , 0 , 0 , 0 ])) elif p > 0 : self . translation_ab5 [ j1 , j2 , p ] = np . power ( 1 j , abs ( m1 - m2 ) - abs ( m1 ) - abs ( m2 ) + l2 - l1 + p ) * np . power ( - 1.0 , m1 - m2 ) * \\ np . sqrt (( 2 * l1 + 1 ) * ( 2 * l2 + 1 ) / ( 2 * l1 * ( l1 + 1 ) * l2 * ( l2 + 1 ))) * \\ np . lib . scimath . sqrt (( l1 + l2 + 1 + p ) * ( l1 + l2 + 1 - p ) * ( p + l1 - l2 ) * ( p - l1 + l2 ) * ( 2 * p + 1 )) * \\ wig . wig3jj_array ( 2 * np . array ([ l1 , l2 , p , m1 , - m2 , - m1 + m2 ])) * wig . wig3jj_array ( 2 * np . array ([ l1 , l2 , p - 1 , 0 , 0 , 0 ])) wig . wig_table_free () wig . wig_temp_free ()","title":"compute_translation_table()"},{"location":"references/numerics/#src.numerics.Numerics.compute_fibonacci_sphere_points","text":"Source code in src/numerics.py 131 132 133 134 135 136 137 138 139 140 141 @staticmethod def compute_fibonacci_sphere_points ( n = 100 ): golden_ratio = ( 1 + 5 ** 0.5 ) / 2 i = np . arange ( 0 , n ) phi = 2 * np . pi * ( i / golden_ratio % 1 ) theta = np . arccos ( 1 - 2 * i / n ) return np . stack (( np . sin ( theta ) * np . cos ( phi ), np . sin ( theta ) * np . sin ( phi ), np . cos ( theta )), axis = 1 ), theta , phi","title":"compute_fibonacci_sphere_points()"},{"location":"references/numerics/#src.numerics.Numerics.compute_spherical_unity_vectors","text":"Source code in src/numerics.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 def compute_spherical_unity_vectors ( self ): self . e_r = np . stack (( np . sin ( self . polar_angles ) * np . cos ( self . azimuthal_angles ), np . sin ( self . polar_angles ) * np . sin ( self . azimuthal_angles ), np . cos ( self . polar_angles )), axis = 1 ) self . e_theta = np . stack (( np . cos ( self . polar_angles ) * np . cos ( self . azimuthal_angles ), np . cos ( self . polar_angles ) * np . sin ( self . azimuthal_angles ), - np . sin ( self . polar_angles )), axis = 1 ) self . e_phi = np . stack (( - np . sin ( self . azimuthal_angles ), np . cos ( self . azimuthal_angles ), np . zeros_like ( self . azimuthal_angles )), axis = 1 )","title":"compute_spherical_unity_vectors()"},{"location":"references/optics/","text":"Optics ( simulation ) Source code in src/optics.py 16 17 18 19 20 21 22 23 24 def __init__ ( self , simulation : Simulation ): self . simulation = simulation self . c_ext = np . zeros_like ( simulation . parameters . wavelength , dtype = complex ) self . c_sca = np . zeros_like ( simulation . parameters . wavelength , dtype = complex ) self . log = logging . getLogger ( __name__ ) simulation = simulation instance-attribute c_ext = np . zeros_like ( simulation . parameters . wavelength , dtype = complex ) instance-attribute c_sca = np . zeros_like ( simulation . parameters . wavelength , dtype = complex ) instance-attribute log = logging . getLogger ( __name__ ) instance-attribute compute_cross_sections () Source code in src/optics.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def compute_cross_sections ( self ): a = self . simulation . initial_field_coefficients f = self . simulation . scattered_field_coefficients self . c_ext = np . zeros ( self . simulation . parameters . wavelengths_number , dtype = complex ) self . c_ext -= np . sum ( np . conjugate ( a ) * f , axis = ( 0 , 1 )) / \\ np . power ( self . simulation . parameters . k_medium , 2 ) * np . pi lmax = self . simulation . numerics . lmax particle_number = self . simulation . parameters . particles . number wavelengths = self . simulation . parameters . k_medium . shape [ 0 ] translation_table = self . simulation . numerics . translation_ab5 associated_legendre_lookup = self . simulation . plm spherical_bessel_lookup = self . simulation . sph_j e_j_dm_phi_loopup = self . simulation . e_j_dm_phi idx_lookup = self . simulation . idx_lookup if self . simulation . numerics . gpu : c_sca_real = np . zeros ( wavelengths , dtype = float ) c_sca_imag = np . zeros_like ( c_sca_real ) idx_device = cuda . to_device ( idx_lookup ) sfc_device = cuda . to_device ( f ) c_sca_real_device = cuda . to_device ( c_sca_real ) c_sca_imag_device = cuda . to_device ( c_sca_imag ) translation_device = cuda . to_device ( translation_table ) associated_legendre_device = cuda . to_device ( associated_legendre_lookup ) spherical_bessel_device = cuda . to_device ( spherical_bessel_lookup ) e_j_dm_phi_device = cuda . to_device ( e_j_dm_phi_loopup ) jmax = particle_number * 2 * lmax * ( lmax + 2 ) threads_per_block = ( 16 , 16 , 2 ) blocks_per_grid_x = ceil ( jmax / threads_per_block [ 0 ]) blocks_per_grid_y = ceil ( jmax / threads_per_block [ 1 ]) blocks_per_grid_z = ceil ( wavelengths / threads_per_block [ 2 ]) blocks_per_grid = ( blocks_per_grid_x , blocks_per_grid_y , blocks_per_grid_z ) compute_scattering_cross_section_gpu [ blocks_per_grid , threads_per_block ]( lmax , particle_number , idx_device , sfc_device , translation_device , associated_legendre_device , spherical_bessel_device , e_j_dm_phi_device , c_sca_real_device , c_sca_imag_device ) c_sca_real = c_sca_real_device . copy_to_host () c_sca_imag = c_sca_imag_device . copy_to_host () c_sca = c_sca_real + 1 j * c_sca_imag else : # from numba_progress import ProgressBar # num_iterations = jmax * jmax * wavelengths # progress = ProgressBar(total=num_iterations) progress = None c_sca = compute_scattering_cross_section ( lmax , particle_number , idx_lookup , f , translation_table , associated_legendre_lookup , spherical_bessel_lookup , e_j_dm_phi_loopup , progress ) self . c_sca = c_sca / \\ np . power ( self . simulation . parameters . k_medium , 2 ) * np . pi self . c_ext = np . real ( self . c_ext ) self . c_sca = np . real ( self . c_sca ) self . albedo = self . c_sca / self . c_ext compute_phase_funcition ( legendre_coefficients_number = 15 , c_and_b = False ) Source code in src/optics.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 def compute_phase_funcition ( self , legendre_coefficients_number : int = 15 , c_and_b : Union [ bool , tuple ] = False ): pilm , taulm = spherical_functions_trigon ( self . simulation . numerics . polar_angles , self . simulation . numerics . lmax ) if self . simulation . numerics . gpu : jmax = self . simulation . parameters . particles . number * self . simulation . numerics . nmax angles = self . simulation . numerics . azimuthal_angles . size wavelengths = self . simulation . parameters . k_medium . size e_1_sca_real = np . zeros (( self . simulation . numerics . azimuthal_angles . size , 3 , self . simulation . parameters . k_medium . size ), dtype = float ) e_1_sca_imag = np . zeros_like ( e_1_sca_real ) particles_position = cuda . to_device ( self . simulation . parameters . particles . pos ) idx_device = cuda . to_device ( self . simulation . idx_lookup ) sfc_device = cuda . to_device ( self . simulation . scattered_field_coefficients ) k_medium_device = cuda . to_device ( self . simulation . parameters . k_medium ) azimuthal_angles_device = cuda . to_device ( self . simulation . numerics . azimuthal_angles ) e_r_device = cuda . to_device ( self . simulation . numerics . e_r ) e_phi_device = cuda . to_device ( self . simulation . numerics . e_phi ) e_theta_device = cuda . to_device ( self . simulation . numerics . e_theta ) pilm_device = cuda . to_device ( pilm ) taulm_device = cuda . to_device ( taulm ) e_1_sca_real_device = cuda . to_device ( e_1_sca_real ) e_1_sca_imag_device = cuda . to_device ( e_1_sca_imag ) threads_per_block = ( 16 , 16 , 2 ) blocks_per_grid_x = ceil ( jmax / threads_per_block [ 0 ]) blocks_per_grid_y = ceil ( angles / threads_per_block [ 1 ]) blocks_per_grid_z = ceil ( wavelengths / threads_per_block [ 2 ]) blocks_per_grid = ( blocks_per_grid_x , blocks_per_grid_y , blocks_per_grid_z ) compute_radial_independent_scattered_field_gpu [ blocks_per_grid , threads_per_block ]( self . simulation . numerics . lmax , particles_position , idx_device , sfc_device , k_medium_device , azimuthal_angles_device , e_r_device , e_phi_device , e_theta_device , pilm_device , taulm_device , e_1_sca_real_device , e_1_sca_imag_device ) e_1_sca_real = e_1_sca_real_device . copy_to_host () e_1_sca_imag = e_1_sca_imag_device . copy_to_host () e_1_sca = e_1_sca_real + 1 j * e_1_sca_imag else : e_1_sca = compute_radial_independent_scattered_field ( self . simulation . numerics . lmax , self . simulation . parameters . particles . pos , self . simulation . idx_lookup , self . simulation . scattered_field_coefficients , self . simulation . parameters . k_medium , self . simulation . numerics . azimuthal_angles , self . simulation . numerics . e_r , self . simulation . numerics . e_phi , self . simulation . numerics . e_theta , pilm , taulm ) self . scattering_angles = self . simulation . numerics . polar_angles self . phase_function = np . sum ( np . power ( np . abs ( e_1_sca ), 2 ), axis = 1 ) * 4 * np . pi / np . power ( self . simulation . parameters . k_medium , 2 ) / self . c_sca [ np . newaxis , :] self . phase_function_legendre_coefficients = np . polynomial . legendre . legfit ( np . cos ( self . scattering_angles ), self . phase_function , legendre_coefficients_number ) if ( self . simulation . numerics . sampling_points_number is not None ) and ( self . simulation . numerics . sampling_points_number . size == 2 ): self . phase_function = np . mean ( np . reshape ( self . phase_function , np . append ( self . simulation . numerics . sampling_points_number , self . simulation . parameters . k_medium . size )), axis = 0 ) self . scattering_angles = np . reshape ( self . scattering_angles , self . simulation . numerics . sampling_points_number ) self . scattering_angles = self . scattering_angles [ 0 , :] self . c_and_b_bounds = c_and_b if isinstance ( c_and_b , bool ): if c_and_b : self . c_and_b_bounds = ([ - 1 , 0 ], [ 1 , 1 ]) else : return self . __compute_c_and_b () compute_double_henyey_greenstein ( theta , cb ) staticmethod Source code in src/optics.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 @staticmethod def compute_double_henyey_greenstein ( theta : np . ndarray , cb : np . ndarray ): cb = np . squeeze ( cb ) if cb . size < 2 : cb = np . array ([ 0 , 0.5 , 0.5 ]) elif cb . size == 2 : cb = np . append ( cb , cb [ 1 ]) elif cb . size > 3 : cb = cb [: 2 ] p1 = ( 1 - cb [ 1 ] ** 2 ) / np . power ( 1 - 2 * cb [ 1 ] * np . cos ( theta ) + cb [ 1 ] ** 2 , 3 / 2 ) p2 = ( 1 - cb [ 2 ] ** 2 ) / np . power ( 1 + 2 * cb [ 2 ] * np . cos ( theta ) + cb [ 2 ] ** 2 , 3 / 2 ) return ( 1 - cb [ 0 ]) / 2 * p1 + ( 1 + cb [ 0 ]) / 2 * p2 __compute_c_and_b () Source code in src/optics.py 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 def __compute_c_and_b ( self ): # double henyey greenstein if len ( self . c_and_b_bounds [ 0 ]) not in [ 2 , 3 ]: self . c_and_b_bounds = ([ - 1 , 0 ], [ 1 , 1 ]) self . log . warning ( 'Number of parameters need to be 2 (b,c) or 3 (b1,b2,c). Reverting to two parameters (b,c) and setting the bounds to standard: b in [0, 1] and c in [-1, 1]' ) from scipy.optimize import least_squares if len ( self . c_and_b_bounds ) == 2 : bc0 = np . array ([ 0 , 0.5 ]) else : bc0 = np . array ([ 0 , 0.5 , 0.5 ]) self . cb = np . empty ( ( self . phase_function . shape [ 1 ], len ( self . c_and_b_bounds ))) for w in range ( self . phase_function . shape [ 1 ]): def dhg_optimization ( bc ): return ( Optics . compute_double_henyey_greenstein ( self . scattering_angles , bc ) - self . phase_function [:, w ]) bc = least_squares ( dhg_optimization , bc0 , jac = '2-point' , bounds = self . c_and_b_bounds ) self . cb [ w , :] = bc . x","title":"Optics"},{"location":"references/optics/#src.optics.Optics","text":"Source code in src/optics.py 16 17 18 19 20 21 22 23 24 def __init__ ( self , simulation : Simulation ): self . simulation = simulation self . c_ext = np . zeros_like ( simulation . parameters . wavelength , dtype = complex ) self . c_sca = np . zeros_like ( simulation . parameters . wavelength , dtype = complex ) self . log = logging . getLogger ( __name__ )","title":"Optics"},{"location":"references/optics/#src.optics.Optics.simulation","text":"","title":"simulation"},{"location":"references/optics/#src.optics.Optics.c_ext","text":"","title":"c_ext"},{"location":"references/optics/#src.optics.Optics.c_sca","text":"","title":"c_sca"},{"location":"references/optics/#src.optics.Optics.log","text":"","title":"log"},{"location":"references/optics/#src.optics.Optics.compute_cross_sections","text":"Source code in src/optics.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def compute_cross_sections ( self ): a = self . simulation . initial_field_coefficients f = self . simulation . scattered_field_coefficients self . c_ext = np . zeros ( self . simulation . parameters . wavelengths_number , dtype = complex ) self . c_ext -= np . sum ( np . conjugate ( a ) * f , axis = ( 0 , 1 )) / \\ np . power ( self . simulation . parameters . k_medium , 2 ) * np . pi lmax = self . simulation . numerics . lmax particle_number = self . simulation . parameters . particles . number wavelengths = self . simulation . parameters . k_medium . shape [ 0 ] translation_table = self . simulation . numerics . translation_ab5 associated_legendre_lookup = self . simulation . plm spherical_bessel_lookup = self . simulation . sph_j e_j_dm_phi_loopup = self . simulation . e_j_dm_phi idx_lookup = self . simulation . idx_lookup if self . simulation . numerics . gpu : c_sca_real = np . zeros ( wavelengths , dtype = float ) c_sca_imag = np . zeros_like ( c_sca_real ) idx_device = cuda . to_device ( idx_lookup ) sfc_device = cuda . to_device ( f ) c_sca_real_device = cuda . to_device ( c_sca_real ) c_sca_imag_device = cuda . to_device ( c_sca_imag ) translation_device = cuda . to_device ( translation_table ) associated_legendre_device = cuda . to_device ( associated_legendre_lookup ) spherical_bessel_device = cuda . to_device ( spherical_bessel_lookup ) e_j_dm_phi_device = cuda . to_device ( e_j_dm_phi_loopup ) jmax = particle_number * 2 * lmax * ( lmax + 2 ) threads_per_block = ( 16 , 16 , 2 ) blocks_per_grid_x = ceil ( jmax / threads_per_block [ 0 ]) blocks_per_grid_y = ceil ( jmax / threads_per_block [ 1 ]) blocks_per_grid_z = ceil ( wavelengths / threads_per_block [ 2 ]) blocks_per_grid = ( blocks_per_grid_x , blocks_per_grid_y , blocks_per_grid_z ) compute_scattering_cross_section_gpu [ blocks_per_grid , threads_per_block ]( lmax , particle_number , idx_device , sfc_device , translation_device , associated_legendre_device , spherical_bessel_device , e_j_dm_phi_device , c_sca_real_device , c_sca_imag_device ) c_sca_real = c_sca_real_device . copy_to_host () c_sca_imag = c_sca_imag_device . copy_to_host () c_sca = c_sca_real + 1 j * c_sca_imag else : # from numba_progress import ProgressBar # num_iterations = jmax * jmax * wavelengths # progress = ProgressBar(total=num_iterations) progress = None c_sca = compute_scattering_cross_section ( lmax , particle_number , idx_lookup , f , translation_table , associated_legendre_lookup , spherical_bessel_lookup , e_j_dm_phi_loopup , progress ) self . c_sca = c_sca / \\ np . power ( self . simulation . parameters . k_medium , 2 ) * np . pi self . c_ext = np . real ( self . c_ext ) self . c_sca = np . real ( self . c_sca ) self . albedo = self . c_sca / self . c_ext","title":"compute_cross_sections()"},{"location":"references/optics/#src.optics.Optics.compute_phase_funcition","text":"Source code in src/optics.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 def compute_phase_funcition ( self , legendre_coefficients_number : int = 15 , c_and_b : Union [ bool , tuple ] = False ): pilm , taulm = spherical_functions_trigon ( self . simulation . numerics . polar_angles , self . simulation . numerics . lmax ) if self . simulation . numerics . gpu : jmax = self . simulation . parameters . particles . number * self . simulation . numerics . nmax angles = self . simulation . numerics . azimuthal_angles . size wavelengths = self . simulation . parameters . k_medium . size e_1_sca_real = np . zeros (( self . simulation . numerics . azimuthal_angles . size , 3 , self . simulation . parameters . k_medium . size ), dtype = float ) e_1_sca_imag = np . zeros_like ( e_1_sca_real ) particles_position = cuda . to_device ( self . simulation . parameters . particles . pos ) idx_device = cuda . to_device ( self . simulation . idx_lookup ) sfc_device = cuda . to_device ( self . simulation . scattered_field_coefficients ) k_medium_device = cuda . to_device ( self . simulation . parameters . k_medium ) azimuthal_angles_device = cuda . to_device ( self . simulation . numerics . azimuthal_angles ) e_r_device = cuda . to_device ( self . simulation . numerics . e_r ) e_phi_device = cuda . to_device ( self . simulation . numerics . e_phi ) e_theta_device = cuda . to_device ( self . simulation . numerics . e_theta ) pilm_device = cuda . to_device ( pilm ) taulm_device = cuda . to_device ( taulm ) e_1_sca_real_device = cuda . to_device ( e_1_sca_real ) e_1_sca_imag_device = cuda . to_device ( e_1_sca_imag ) threads_per_block = ( 16 , 16 , 2 ) blocks_per_grid_x = ceil ( jmax / threads_per_block [ 0 ]) blocks_per_grid_y = ceil ( angles / threads_per_block [ 1 ]) blocks_per_grid_z = ceil ( wavelengths / threads_per_block [ 2 ]) blocks_per_grid = ( blocks_per_grid_x , blocks_per_grid_y , blocks_per_grid_z ) compute_radial_independent_scattered_field_gpu [ blocks_per_grid , threads_per_block ]( self . simulation . numerics . lmax , particles_position , idx_device , sfc_device , k_medium_device , azimuthal_angles_device , e_r_device , e_phi_device , e_theta_device , pilm_device , taulm_device , e_1_sca_real_device , e_1_sca_imag_device ) e_1_sca_real = e_1_sca_real_device . copy_to_host () e_1_sca_imag = e_1_sca_imag_device . copy_to_host () e_1_sca = e_1_sca_real + 1 j * e_1_sca_imag else : e_1_sca = compute_radial_independent_scattered_field ( self . simulation . numerics . lmax , self . simulation . parameters . particles . pos , self . simulation . idx_lookup , self . simulation . scattered_field_coefficients , self . simulation . parameters . k_medium , self . simulation . numerics . azimuthal_angles , self . simulation . numerics . e_r , self . simulation . numerics . e_phi , self . simulation . numerics . e_theta , pilm , taulm ) self . scattering_angles = self . simulation . numerics . polar_angles self . phase_function = np . sum ( np . power ( np . abs ( e_1_sca ), 2 ), axis = 1 ) * 4 * np . pi / np . power ( self . simulation . parameters . k_medium , 2 ) / self . c_sca [ np . newaxis , :] self . phase_function_legendre_coefficients = np . polynomial . legendre . legfit ( np . cos ( self . scattering_angles ), self . phase_function , legendre_coefficients_number ) if ( self . simulation . numerics . sampling_points_number is not None ) and ( self . simulation . numerics . sampling_points_number . size == 2 ): self . phase_function = np . mean ( np . reshape ( self . phase_function , np . append ( self . simulation . numerics . sampling_points_number , self . simulation . parameters . k_medium . size )), axis = 0 ) self . scattering_angles = np . reshape ( self . scattering_angles , self . simulation . numerics . sampling_points_number ) self . scattering_angles = self . scattering_angles [ 0 , :] self . c_and_b_bounds = c_and_b if isinstance ( c_and_b , bool ): if c_and_b : self . c_and_b_bounds = ([ - 1 , 0 ], [ 1 , 1 ]) else : return self . __compute_c_and_b ()","title":"compute_phase_funcition()"},{"location":"references/optics/#src.optics.Optics.compute_double_henyey_greenstein","text":"Source code in src/optics.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 @staticmethod def compute_double_henyey_greenstein ( theta : np . ndarray , cb : np . ndarray ): cb = np . squeeze ( cb ) if cb . size < 2 : cb = np . array ([ 0 , 0.5 , 0.5 ]) elif cb . size == 2 : cb = np . append ( cb , cb [ 1 ]) elif cb . size > 3 : cb = cb [: 2 ] p1 = ( 1 - cb [ 1 ] ** 2 ) / np . power ( 1 - 2 * cb [ 1 ] * np . cos ( theta ) + cb [ 1 ] ** 2 , 3 / 2 ) p2 = ( 1 - cb [ 2 ] ** 2 ) / np . power ( 1 + 2 * cb [ 2 ] * np . cos ( theta ) + cb [ 2 ] ** 2 , 3 / 2 ) return ( 1 - cb [ 0 ]) / 2 * p1 + ( 1 + cb [ 0 ]) / 2 * p2","title":"compute_double_henyey_greenstein()"},{"location":"references/optics/#src.optics.Optics.__compute_c_and_b","text":"Source code in src/optics.py 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 def __compute_c_and_b ( self ): # double henyey greenstein if len ( self . c_and_b_bounds [ 0 ]) not in [ 2 , 3 ]: self . c_and_b_bounds = ([ - 1 , 0 ], [ 1 , 1 ]) self . log . warning ( 'Number of parameters need to be 2 (b,c) or 3 (b1,b2,c). Reverting to two parameters (b,c) and setting the bounds to standard: b in [0, 1] and c in [-1, 1]' ) from scipy.optimize import least_squares if len ( self . c_and_b_bounds ) == 2 : bc0 = np . array ([ 0 , 0.5 ]) else : bc0 = np . array ([ 0 , 0.5 , 0.5 ]) self . cb = np . empty ( ( self . phase_function . shape [ 1 ], len ( self . c_and_b_bounds ))) for w in range ( self . phase_function . shape [ 1 ]): def dhg_optimization ( bc ): return ( Optics . compute_double_henyey_greenstein ( self . scattering_angles , bc ) - self . phase_function [:, w ]) bc = least_squares ( dhg_optimization , bc0 , jac = '2-point' , bounds = self . c_and_b_bounds ) self . cb [ w , :] = bc . x","title":"__compute_c_and_b()"},{"location":"references/parameters/","text":"Parameters ( wavelength , medium_mefractive_index , particles , initial_field ) Source code in src/parameters.py 10 11 12 13 14 15 16 17 18 19 20 21 def __init__ ( self , wavelength : np . array , medium_mefractive_index : np . array , particles : Particles , initial_field : InitialField ): self . wavelength = wavelength self . medium_mefractive_index = medium_mefractive_index self . wavelengths_number = wavelength . size self . particles = particles self . initial_field = initial_field self . __setup () wavelength = wavelength instance-attribute medium_mefractive_index = medium_mefractive_index instance-attribute wavelengths_number = wavelength . size instance-attribute particles = particles instance-attribute initial_field = initial_field instance-attribute __setup () Source code in src/parameters.py 23 24 25 def __setup ( self ): self . __compute_omega () self . __compute_ks () __compute_omega () Source code in src/parameters.py 27 28 def __compute_omega ( self ): self . omega = 2 * np . pi / self . wavelength __compute_ks () Source code in src/parameters.py 30 31 32 def __compute_ks ( self ): self . k_medium = self . omega * self . medium_mefractive_index self . k_particle = np . outer ( self . particles . m , self . omega )","title":"Parameters"},{"location":"references/parameters/#src.parameters.Parameters","text":"Source code in src/parameters.py 10 11 12 13 14 15 16 17 18 19 20 21 def __init__ ( self , wavelength : np . array , medium_mefractive_index : np . array , particles : Particles , initial_field : InitialField ): self . wavelength = wavelength self . medium_mefractive_index = medium_mefractive_index self . wavelengths_number = wavelength . size self . particles = particles self . initial_field = initial_field self . __setup ()","title":"Parameters"},{"location":"references/parameters/#src.parameters.Parameters.wavelength","text":"","title":"wavelength"},{"location":"references/parameters/#src.parameters.Parameters.medium_mefractive_index","text":"","title":"medium_mefractive_index"},{"location":"references/parameters/#src.parameters.Parameters.wavelengths_number","text":"","title":"wavelengths_number"},{"location":"references/parameters/#src.parameters.Parameters.particles","text":"","title":"particles"},{"location":"references/parameters/#src.parameters.Parameters.initial_field","text":"","title":"initial_field"},{"location":"references/parameters/#src.parameters.Parameters.__setup","text":"Source code in src/parameters.py 23 24 25 def __setup ( self ): self . __compute_omega () self . __compute_ks ()","title":"__setup()"},{"location":"references/parameters/#src.parameters.Parameters.__compute_omega","text":"Source code in src/parameters.py 27 28 def __compute_omega ( self ): self . omega = 2 * np . pi / self . wavelength","title":"__compute_omega()"},{"location":"references/parameters/#src.parameters.Parameters.__compute_ks","text":"Source code in src/parameters.py 30 31 32 def __compute_ks ( self ): self . k_medium = self . omega * self . medium_mefractive_index self . k_particle = np . outer ( self . particles . m , self . omega )","title":"__compute_ks()"},{"location":"references/particles/","text":"Particles ( pos , r , m , type = 'sphere' ) Source code in src/particles.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def __init__ ( self , pos : np . array , r : np . array , m : np . array , type : str = 'sphere' ): self . pos = pos self . r = r self . m = m self . type = type self . log = logging . getLogger ( __name__ ) if self . m . shape [ 1 ] == 2 : self . m = self . m [:, 0 ] + 1 j * self . m [:, 1 ] elif self . m . shape [ 1 ] > 2 : self . log . error ( 'Refractive index should be either complex or a two column matrix!' ) self . number = r . shape [ 0 ] self . __setup_impl () pos = pos instance-attribute r = r instance-attribute m = m instance-attribute type = type instance-attribute log = logging . getLogger ( __name__ ) instance-attribute number = r . shape [ 0 ] instance-attribute compute_unique_refractive_indices () Source code in src/particles.py 26 27 28 29 30 31 def compute_unique_refractive_indices ( self ): self . unique_refractive_indices , self . refractive_index_array_idx = np . unique ( self . m , return_inverse = True , axis = 0 ) self . num_unique_refractive_indices = self . unique_refractive_indices . shape [ 0 ] compute_unique_radii () Source code in src/particles.py 33 34 35 36 37 38 def compute_unique_radii ( self ): self . unqiue_radii , self . radius_array_idx = np . unique ( self . r , return_inverse = True , axis = 0 ) self . num_unique_radii = self . unqiue_radii . shape [ 0 ] compute_unique_radii_index_pairs () Source code in src/particles.py 40 41 42 43 44 45 46 47 48 def compute_unique_radii_index_pairs ( self ): self . unique_radius_index_pairs , self . single_unique_array_idx = np . unique ( np . column_stack (( self . r , self . m )), return_inverse = True , axis = 0 ) self . unique_single_radius_index_pairs = np . unique ( np . column_stack ( ( self . radius_array_idx , self . refractive_index_array_idx )), axis = 0 ) compute_single_unique_idx () Source code in src/particles.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def compute_single_unique_idx ( self ): self . single_unique_idx = ( np . sum ( self . unique_single_radius_index_pairs , axis = 1 ) * ( np . sum ( self . unique_single_radius_index_pairs , axis = 1 ) + 1 ) ) // 2 + self . unique_single_radius_index_pairs [:, 1 ] # pairedArray = ( # self.radius_array_idx + self.refractive_index_array_idx * # (self.radius_array_idx + self.refractive_index_array_idx + 1) # ) // 2 + self.refractive_index_array_idx # self.single_unique_idx, self.single_unique_array_idx = np.unique( # pairedArray, # return_inverse=True, # axis=0) self . num_unique_pairs = self . unique_radius_index_pairs . shape [ 0 ] compute_maximal_particle_distance () Source code in src/particles.py 68 69 70 71 def compute_maximal_particle_distance ( self ): hull = ConvexHull ( self . pos ) vert = self . pos [ hull . vertices , :] self . max_particle_distance = max ( pdist ( vert )) compute_volume_equivalent_area () Source code in src/particles.py 73 74 75 def compute_volume_equivalent_area ( self ): r3 = np . power ( self . r , 3 ) self . geometric_projection = np . pi * np . power ( np . sum ( r3 ), 2 / 3 ) __setup_impl () Source code in src/particles.py 77 78 79 80 81 82 def __setup_impl ( self ): self . compute_unique_refractive_indices () self . compute_unique_radii () self . compute_unique_radii_index_pairs () self . compute_single_unique_idx () self . compute_maximal_particle_distance ()","title":"Particles"},{"location":"references/particles/#src.particles.Particles","text":"Source code in src/particles.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def __init__ ( self , pos : np . array , r : np . array , m : np . array , type : str = 'sphere' ): self . pos = pos self . r = r self . m = m self . type = type self . log = logging . getLogger ( __name__ ) if self . m . shape [ 1 ] == 2 : self . m = self . m [:, 0 ] + 1 j * self . m [:, 1 ] elif self . m . shape [ 1 ] > 2 : self . log . error ( 'Refractive index should be either complex or a two column matrix!' ) self . number = r . shape [ 0 ] self . __setup_impl ()","title":"Particles"},{"location":"references/particles/#src.particles.Particles.pos","text":"","title":"pos"},{"location":"references/particles/#src.particles.Particles.r","text":"","title":"r"},{"location":"references/particles/#src.particles.Particles.m","text":"","title":"m"},{"location":"references/particles/#src.particles.Particles.type","text":"","title":"type"},{"location":"references/particles/#src.particles.Particles.log","text":"","title":"log"},{"location":"references/particles/#src.particles.Particles.number","text":"","title":"number"},{"location":"references/particles/#src.particles.Particles.compute_unique_refractive_indices","text":"Source code in src/particles.py 26 27 28 29 30 31 def compute_unique_refractive_indices ( self ): self . unique_refractive_indices , self . refractive_index_array_idx = np . unique ( self . m , return_inverse = True , axis = 0 ) self . num_unique_refractive_indices = self . unique_refractive_indices . shape [ 0 ]","title":"compute_unique_refractive_indices()"},{"location":"references/particles/#src.particles.Particles.compute_unique_radii","text":"Source code in src/particles.py 33 34 35 36 37 38 def compute_unique_radii ( self ): self . unqiue_radii , self . radius_array_idx = np . unique ( self . r , return_inverse = True , axis = 0 ) self . num_unique_radii = self . unqiue_radii . shape [ 0 ]","title":"compute_unique_radii()"},{"location":"references/particles/#src.particles.Particles.compute_unique_radii_index_pairs","text":"Source code in src/particles.py 40 41 42 43 44 45 46 47 48 def compute_unique_radii_index_pairs ( self ): self . unique_radius_index_pairs , self . single_unique_array_idx = np . unique ( np . column_stack (( self . r , self . m )), return_inverse = True , axis = 0 ) self . unique_single_radius_index_pairs = np . unique ( np . column_stack ( ( self . radius_array_idx , self . refractive_index_array_idx )), axis = 0 )","title":"compute_unique_radii_index_pairs()"},{"location":"references/particles/#src.particles.Particles.compute_single_unique_idx","text":"Source code in src/particles.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def compute_single_unique_idx ( self ): self . single_unique_idx = ( np . sum ( self . unique_single_radius_index_pairs , axis = 1 ) * ( np . sum ( self . unique_single_radius_index_pairs , axis = 1 ) + 1 ) ) // 2 + self . unique_single_radius_index_pairs [:, 1 ] # pairedArray = ( # self.radius_array_idx + self.refractive_index_array_idx * # (self.radius_array_idx + self.refractive_index_array_idx + 1) # ) // 2 + self.refractive_index_array_idx # self.single_unique_idx, self.single_unique_array_idx = np.unique( # pairedArray, # return_inverse=True, # axis=0) self . num_unique_pairs = self . unique_radius_index_pairs . shape [ 0 ]","title":"compute_single_unique_idx()"},{"location":"references/particles/#src.particles.Particles.compute_maximal_particle_distance","text":"Source code in src/particles.py 68 69 70 71 def compute_maximal_particle_distance ( self ): hull = ConvexHull ( self . pos ) vert = self . pos [ hull . vertices , :] self . max_particle_distance = max ( pdist ( vert ))","title":"compute_maximal_particle_distance()"},{"location":"references/particles/#src.particles.Particles.compute_volume_equivalent_area","text":"Source code in src/particles.py 73 74 75 def compute_volume_equivalent_area ( self ): r3 = np . power ( self . r , 3 ) self . geometric_projection = np . pi * np . power ( np . sum ( r3 ), 2 / 3 )","title":"compute_volume_equivalent_area()"},{"location":"references/particles/#src.particles.Particles.__setup_impl","text":"Source code in src/particles.py 77 78 79 80 81 82 def __setup_impl ( self ): self . compute_unique_refractive_indices () self . compute_unique_radii () self . compute_unique_radii_index_pairs () self . compute_single_unique_idx () self . compute_maximal_particle_distance ()","title":"__setup_impl()"},{"location":"references/simulation/","text":"Simulation ( parameters , numerics ) Pyles Simulation Class Attributes: Name Type Description parameters Parameters Provided object of the instance Parameters numerics Numerics Provided object of the instance Numerics log logging Object for writing logs to Parameters: Name Type Description Default parameters Parameters Object of the instance Parameters required numerics Numerics Object of the instance Numerics required Source code in src/simulation.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 def __init__ ( self , parameters : Parameters , numerics : Numerics ): \"\"\" Parameters ---------- parameters Object of the instance `Parameters` numerics Object of the instance `Numerics` \"\"\" self . parameters = parameters self . numerics = numerics self . log = logging . getLogger ( __name__ ) self . __setup () parameters = parameters instance-attribute numerics = numerics instance-attribute log = logging . getLogger ( __name__ ) instance-attribute legacy_compute_lookup_particle_distances () The largest distance distance between two particles is divided into segments provided by Numerics.particle_distance_resolution . This array is then used as a lookup for the caolcuation of the spherical hankel function. Notes This function has been ported from the Matlab Celes framework but is not used by Pyles! Source code in src/simulation.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def legacy_compute_lookup_particle_distances ( self ): \"\"\" The largest distance distance between two particles is divided into segments provided by `Numerics.particle_distance_resolution`. This array is then used as a lookup for the caolcuation of the spherical hankel function. Notes ----- This function has been ported from the Matlab Celes framework but is not used by Pyles! \"\"\" # add two zeros at beginning to allow interpolation # also in the first segment step = self . numerics . particle_distance_resolution maxdist = self . parameters . particles . max_particle_distance + \\ 3 * self . numerics . particle_distance_resolution self . lookup_particle_distances = np . concatenate ( ( np . array ([ 0 ]), np . arange ( 0 , maxdist + np . finfo ( float ) . eps , step ))) legacy_compute_h3_table () Computes the spherical hankel function at the points calculated in Simulation.legacy_compute_lookup_particle_distances() . Attributes: Name Type Description h3_table np . ndarray Lookup table of the spherical hankel function values at self.lookup_particle_distances Notes This function has been ported from the Matlab Celes framework but is not used by Pyles! Source code in src/simulation.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def legacy_compute_h3_table ( self ): \"\"\" Computes the spherical hankel function at the points calculated in [Simulation.legacy_compute_lookup_particle_distances()][src.simulation.Simulation.legacy_compute_lookup_particle_distances]. Attributes ---------- h3_table : np.ndarray Lookup table of the spherical hankel function values at `self.lookup_particle_distances` Notes ----- This function has been ported from the Matlab Celes framework but is not used by Pyles! \"\"\" self . h3_table = np . zeros ( ( 2 * self . numerics . lmax + 1 , self . lookup_particle_distances . shape [ 0 ], self . parameters . medium_mefractive_index . shape [ 0 ]), dtype = complex ) size_param = np . outer ( self . lookup_particle_distances , self . parameters . k_medium ) for p in range ( 2 * self . numerics . lmax + 1 ): self . h3_table [ p , :, :] = \\ spherical_jn ( p , size_param ) + 1 j * \\ spherical_yn ( p , size_param ) __compute_idx_lookup () Creates a lookup table with the indices using in further calculations. The lookup table is created using compute_idx_lookups . Attributes: Name Type Description idx_lookup np . ndarray Lookup table of the indices to iterate over large arrays. Notes This function uses numba under the hood to speed up the computations. Source code in src/simulation.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 def __compute_idx_lookup ( self ): \"\"\" Creates a lookup table with the indices using in further calculations. The lookup table is created using [compute_idx_lookups][src.functions.cpu_numba.compute_idx_lookups]. Attributes ---------- idx_lookup : np.ndarray Lookup table of the indices to iterate over large arrays. Notes ----- This function uses [numba](https://numba.pydata.org/) under the hood to speed up the computations. \"\"\" self . idx_lookup = compute_idx_lookups ( self . numerics . lmax , self . parameters . particles . number ) __compute_lookups () Computes various lookup tables for each particle: Spherical Bessel function \\(j_n\\) Spherical Hankel function \\(h_n^{(1)}\\) Associated Legendre polynomial values \\(P_l^m\\) Exponential function value \\(e^{j (m_2-m_1) \\phi}\\) Attributes: Name Type Description sph_j np . ndarray Spherical Bessel function lookup table calculated for pair-wise particles distances sph_h np . ndarray Spherical Hankel function lookup table calculated for pair-wise particles distances plm np . ndarray Associated Legendre polynomial lookup table calculated for the cosine value of the pairwise particle inclination angles e_j_dm_phi np . ndarray Exponential function lookup table calculated for the pairwise particle azimuthal angles Notes This function uses numba under the hood to speed up the computations. Source code in src/simulation.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 def __compute_lookups ( self ): \"\"\" Computes various lookup tables for each particle: - Spherical Bessel function $j_n$ - Spherical Hankel function $h_n^{(1)}$ - Associated Legendre polynomial values $P_l^m$ - Exponential function value $e^{j (m_2-m_1) \\\\phi}$ Attributes ---------- sph_j : np.ndarray Spherical Bessel function lookup table calculated for pair-wise particles distances sph_h : np.ndarray Spherical Hankel function lookup table calculated for pair-wise particles distances plm : np.ndarray Associated Legendre polynomial lookup table calculated for the cosine value of the pairwise particle inclination angles e_j_dm_phi : np.ndarray Exponential function lookup table calculated for the pairwise particle azimuthal angles Notes ----- This function uses [numba](https://numba.pydata.org/) under the hood to speed up the computations. \"\"\" lookup_computation_time_start = time () lmax = self . numerics . lmax particle_number = self . parameters . particles . number dists = squareform ( pdist ( self . parameters . particles . pos )) ct = np . divide ( np . subtract . outer ( self . parameters . particles . pos [:, 2 ], self . parameters . particles . pos [:, 2 ]), dists , out = np . zeros (( particle_number , particle_number )), where = dists != 0 ) phi = np . arctan2 ( np . subtract . outer ( self . parameters . particles . pos [:, 1 ], self . parameters . particles . pos [:, 1 ]), np . subtract . outer ( self . parameters . particles . pos [:, 0 ], self . parameters . particles . pos [:, 0 ])) size_param = np . outer ( dists . ravel (), self . parameters . k_medium ) . reshape ( [ particle_number , particle_number , self . parameters . k_medium . shape [ 0 ]]) self . sph_h = np . zeros (( 2 * lmax + 1 , particle_number , particle_number , self . parameters . k_medium . shape [ 0 ]), dtype = complex ) self . sph_j = np . zeros_like ( self . sph_h ) self . e_j_dm_phi = np . zeros ( ( 4 * lmax + 1 , particle_number , particle_number ), dtype = complex ) self . plm = np . zeros ((( lmax + 1 ) * ( 2 * lmax + 1 ), particle_number , particle_number )) for p in range ( 2 * lmax + 1 ): self . sph_h [ p , :, :, :] = np . sqrt ( np . divide ( np . pi / 2 , size_param , out = np . zeros_like ( size_param ), where = size_param != 0 )) * hankel1 ( p + 1 / 2 , size_param ) self . sph_j [ p , :, :, :] = spherical_jn ( p , size_param ) self . e_j_dm_phi [ p , :, :] = np . exp ( 1 j * ( p - 2 * lmax ) * phi ) self . e_j_dm_phi [ p + 2 * lmax , :, :] = np . exp ( 1 j * p * phi ) for absdm in range ( p + 1 ): cml = np . sqrt (( 2 * p + 1 ) / 2 / np . prod ( np . arange ( p - absdm + 1 , p + absdm + 1 ))) self . plm [ p * ( p + 1 ) // 2 + absdm , :, :] = cml * \\ np . power ( - 1.0 , absdm ) * lpmv ( absdm , p , ct ) self . sph_h = np . nan_to_num ( self . sph_h , nan = 0 ) + np . isnan ( self . sph_h ) * 1 lookup_computation_time_stop = time () self . log . info ( 'Computing lookup tables took %f s' % ( lookup_computation_time_stop - lookup_computation_time_start )) __setup () An internal setup function called upon object creation. The following functions are called: __compute_idx_lookups __compute_lookups Source code in src/simulation.py 194 195 196 197 198 199 200 201 202 203 def __setup ( self ): \"\"\" An internal setup function called upon object creation. The following functions are called: - [__compute_idx_lookups][src.simulation.Simulation.__compute_idx_lookup] - [__compute_lookups][src.simulation.Simulation.__compute_lookups] \"\"\" self . __compute_idx_lookup () self . __compute_lookups () compute_mie_coefficients () Computes the mie coefficients for the unique pair of particle radius and the refractive index of the particle. Attributes: Name Type Description mie_coefficients np . ndarray Mie coefficients table See Also t_entry : T-Matrix entry function Notes Due to the four nested loops (particles, tau, l, and m), it could be rewritten using numba to speed the process up. Source code in src/simulation.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 def compute_mie_coefficients ( self ): \"\"\" Computes the mie coefficients for the unique pair of particle radius and the refractive index of the particle. Attributes ---------- mie_coefficients : np.ndarray Mie coefficients table See Also -------- [t_entry][src.functions.t_entry.t_entry] : T-Matrix entry function Notes ----- Due to the four nested loops (particles, tau, l, and m), it could be rewritten using `numba` to speed the process up. \"\"\" self . mie_coefficients = np . zeros ( ( self . parameters . particles . num_unique_pairs , self . numerics . nmax , self . parameters . wavelength . shape [ 0 ]), dtype = complex ) for u_i in range ( self . parameters . particles . num_unique_pairs ): for tau in range ( 1 , 3 ): for l in range ( 1 , self . numerics . lmax + 1 ): for m in range ( - l , l + 1 ): jmult = multi2single_index ( 0 , tau , l , m , self . numerics . lmax ) self . mie_coefficients [ u_i , jmult , :] = t_entry ( tau = tau , l = l , k_medium = self . parameters . k_medium , k_sphere = self . parameters . omega * self . parameters . particles . unique_radius_index_pairs [ u_i , 1 ], radius = np . real ( self . parameters . particles . unique_radius_index_pairs [ u_i , 0 ])) compute_initial_field_coefficients () Computes initial field coefficients \\(a_{\\tau ,l,m}\\) and \\(b_{\\tau ,l,m}\\) . Depending on the beam_width , one of two functions is called: __compute_initial_field_coefficients_wavebundle_normal_incidence , \\(\\text{beam width} \\in (0, \\infty)\\) __compute_initial_field_coefficients_planewave , \\(\\text{beam width} = 0\\) or \\(\\text{beam width} = \\infty\\) Attributes: Name Type Description initial_field_coefficients np . ndarray Initial field coefficients Source code in src/simulation.py 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 def compute_initial_field_coefficients ( self ): \"\"\" Computes initial field coefficients $a_{\\\\tau ,l,m}$ and $b_{\\\\tau ,l,m}$. Depending on the `beam_width`, one of two functions is called: - [__compute_initial_field_coefficients_wavebundle_normal_incidence][src.simulation.Simulation.__compute_initial_field_coefficients_wavebundle_normal_incidence], $\\\\text{beam width} \\\\in (0, \\\\infty)$ - [__compute_initial_field_coefficients_planewave][src.simulation.Simulation.__compute_initial_field_coefficients_planewave], $\\\\text{beam width} = 0$ or $\\\\text{beam width} = \\\\infty$ Attributes ---------- initial_field_coefficients : np.ndarray Initial field coefficients \"\"\" self . log . info ( 'compute initial field coefficients ...' ) if np . isfinite ( self . parameters . initial_field . beam_width ) and ( self . parameters . initial_field . beam_width > 0 ): self . log . info ( ' \\t Gaussian beam ...' ) if self . parameters . initial_field . normal_incidence : self . __compute_initial_field_coefficients_wavebundle_normal_incidence () else : self . log . error ( ' \\t this case is not implemented' ) else : self . log . info ( ' \\t plane wave ...' ) self . __compute_initial_field_coefficients_planewave () self . log . info ( 'done' ) compute_right_hand_side () The right hand side \\(T \\cdot a_I\\) of the equation \\(M \\cdot b = T \\cdot a_I\\) is computed. Attributes: Name Type Description right_hand_side np . ndarray Right hand side of \\(M \\cdot b = T \\cdot a_I\\) Notes For more information regarding the equation, please have a look at the paper of Celes . Source code in src/simulation.py 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 def compute_right_hand_side ( self ): \"\"\" The right hand side $T \\\\cdot a_I$ of the equation $M \\\\cdot b = T \\\\cdot a_I$ is computed. Attributes ---------- right_hand_side : np.ndarray Right hand side of $M \\\\cdot b = T \\\\cdot a_I$ Notes ----- For more information regarding the equation, please have a look at the paper of [Celes](https://arxiv.org/abs/1706.02145). \"\"\" self . right_hand_side = self . mie_coefficients [ self . parameters . particles . single_unique_array_idx , :] * self . initial_field_coefficients __compute_initial_field_coefficients_planewave () Source code in src/simulation.py 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 def __compute_initial_field_coefficients_planewave ( self ): lmax = self . numerics . lmax E0 = self . parameters . initial_field . amplitude k = self . parameters . k_medium beta = self . parameters . initial_field . polar_angle cb = np . cos ( beta ) sb = np . sin ( beta ) alpha = self . parameters . initial_field . azimuthal_angle # pi and tau symbols for transformation matrix B_dagger pilm , taulm = spherical_functions_trigon ( beta , lmax ) # cylindrical coordinates for relative particle positions relative_particle_positions = self . parameters . particles . pos - \\ self . parameters . initial_field . focal_point kvec = np . outer ( np . array (( sb * np . cos ( alpha ), sb * np . sin ( alpha ), cb )), k ) eikr = np . exp ( 1 j * np . matmul ( relative_particle_positions , kvec )) # clean up some memory? del ( k , beta , cb , sb , kvec , relative_particle_positions ) self . initial_field_coefficients = np . zeros ( ( self . parameters . particles . number , self . numerics . nmax , self . parameters . k_medium . size ), dtype = complex ) for m in range ( - lmax , lmax + 1 ): for tau in range ( 1 , 3 ): for l in range ( np . max ([ 1 , np . abs ( m )]), lmax + 1 ): n = multi2single_index ( 0 , tau , l , m , lmax ) self . initial_field_coefficients [:, n , :] = 4 * E0 * np . exp ( - 1 j * m * alpha ) * eikr * transformation_coefficients ( pilm , taulm , tau , l , m , self . parameters . initial_field . pol , dagger = True ) __compute_initial_field_coefficients_wavebundle_normal_incidence () TODO Implement this function using the celes function initial_field_coefficients_wavebundle_normal_incidence.m Source code in src/simulation.py 317 318 319 320 321 322 323 324 def __compute_initial_field_coefficients_wavebundle_normal_incidence ( self ): \"\"\" TODO ---- Implement this function using the celes function [initial_field_coefficients_wavebundle_normal_incidence.m](https://github.com/disordered-photonics/celes/blob/master/src/initial/initial_field_coefficients_wavebundle_normal_incidence.m) \"\"\" self . initial_field_coefficients = np . zeros ( ( self . parameters . particles . number , self . numerics . nmax , self . parameters . k_medium . size ), dtype = complex ) * np . nan coupling_matrix_multiply ( x , idx = None ) Source code in src/simulation.py 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 def coupling_matrix_multiply ( self , x : np . ndarray , idx : int = None ): self . log . info ( 'prepare particle coupling ... ' ) preparation_time = time () lmax = self . numerics . lmax particle_number = self . parameters . particles . number jmax = particle_number * 2 * lmax * ( lmax + 2 ) wavelengths = self . parameters . k_medium . shape [ 0 ] translation_table = self . numerics . translation_ab5 associated_legendre_lookup = self . plm spherical_hankel_lookup = self . sph_h e_j_dm_phi_loopup = self . e_j_dm_phi idx_lookup = self . idx_lookup if idx != None : spherical_hankel_lookup = spherical_hankel_lookup [:, :, :, idx ] spherical_hankel_lookup = np . copy ( spherical_hankel_lookup [:, :, :, np . newaxis ]) wavelengths = 1 self . log . info ( ' \\t Starting Wx computation' ) if self . numerics . gpu : wx_real = np . zeros ( x . shape + ( wavelengths ,), dtype = float ) wx_imag = np . zeros_like ( wx_real ) idx_device = cuda . to_device ( idx_lookup ) x_device = cuda . to_device ( x ) wx_real_device = cuda . to_device ( wx_real ) wx_imag_device = cuda . to_device ( wx_imag ) translation_device = cuda . to_device ( translation_table ) associated_legendre_device = cuda . to_device ( associated_legendre_lookup ) spherical_hankel_device = cuda . to_device ( spherical_hankel_lookup ) e_j_dm_phi_device = cuda . to_device ( e_j_dm_phi_loopup ) threads_per_block = ( 16 , 16 , 2 ) blocks_per_grid_x = ceil ( jmax / threads_per_block [ 0 ]) blocks_per_grid_y = ceil ( jmax / threads_per_block [ 1 ]) blocks_per_grid_z = ceil ( wavelengths / threads_per_block [ 2 ]) blocks_per_grid = ( blocks_per_grid_x , blocks_per_grid_y , blocks_per_grid_z ) coupling_matrix_time = time () particle_interaction_gpu [ blocks_per_grid , threads_per_block ]( lmax , particle_number , idx_device , x_device , wx_real_device , wx_imag_device , translation_device , associated_legendre_device , spherical_hankel_device , e_j_dm_phi_device ) wx_real = wx_real_device . copy_to_host () wx_imag = wx_imag_device . copy_to_host () wx = wx_real + 1 j * wx_imag # particle_interaction.parallel_diagnostics(level=4) time_end = time () self . log . info ( \" \\t Time taken for preparation: %f \" % ( coupling_matrix_time - preparation_time )) self . log . info ( \" \\t Time taken for coupling matrix: %f \" % ( time_end - coupling_matrix_time )) else : # from numba_progress import ProgressBar # num_iterations = jmax * jmax * wavelengths # progress = ProgressBar(total=num_iterations) progress = None wx = particle_interaction ( lmax , particle_number , idx_lookup , x , translation_table , associated_legendre_lookup , spherical_hankel_lookup , e_j_dm_phi_loopup , progress ) time_end = time () self . log . info ( \" \\t Time taken for coupling matrix: %f \" % ( time_end - preparation_time )) if idx != None : wx = np . squeeze ( wx ) return wx master_matrix_multiply ( value , idx ) Source code in src/simulation.py 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 def master_matrix_multiply ( self , value : np . ndarray , idx : int ): wx = self . coupling_matrix_multiply ( value , idx ) self . log . info ( 'apply T-matrix ...' ) t_matrix_start = time () twx = self . mie_coefficients [ self . parameters . particles . single_unique_array_idx , :, idx ] . ravel ( order = 'C' ) * wx mx = value - twx t_matrix_stop = time () self . log . info ( ' \\t done in %f seconds.' % ( t_matrix_stop - t_matrix_start )) return mx compute_scattered_field_coefficients ( guess = None ) Source code in src/simulation.py 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 def compute_scattered_field_coefficients ( self , guess = None ): self . log . info ( 'compute scattered field coefficients ...' ) jmax = self . parameters . particles . number * self . numerics . nmax self . scattered_field_coefficients = np . zeros_like ( self . initial_field_coefficients ) self . scattered_field_err_codes = np . zeros ( self . parameters . wavelengths_number ) if guess is None : guess = self . right_hand_side for w in range ( self . parameters . wavelengths_number ): def mmm ( x ): return self . master_matrix_multiply ( x , w ) A = LinearOperator ( shape = ( jmax , jmax ), matvec = mmm ) b = self . right_hand_side [:, :, w ] . ravel () x0 = guess [:, :, w ] . ravel () self . log . info ( 'Solver run %d / %d ' % ( w + 1 , self . parameters . wavelengths_number )) x , err_code = self . numerics . solver . run ( A , b , x0 ) self . scattered_field_coefficients [:, :, w ] = x . reshape ( self . right_hand_side . shape [: 2 ]) self . scattered_field_err_codes [ w ] = err_code","title":"Simulation"},{"location":"references/simulation/#src.simulation.Simulation","text":"Pyles Simulation Class Attributes: Name Type Description parameters Parameters Provided object of the instance Parameters numerics Numerics Provided object of the instance Numerics log logging Object for writing logs to Parameters: Name Type Description Default parameters Parameters Object of the instance Parameters required numerics Numerics Object of the instance Numerics required Source code in src/simulation.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 def __init__ ( self , parameters : Parameters , numerics : Numerics ): \"\"\" Parameters ---------- parameters Object of the instance `Parameters` numerics Object of the instance `Numerics` \"\"\" self . parameters = parameters self . numerics = numerics self . log = logging . getLogger ( __name__ ) self . __setup ()","title":"Simulation"},{"location":"references/simulation/#src.simulation.Simulation.parameters","text":"","title":"parameters"},{"location":"references/simulation/#src.simulation.Simulation.numerics","text":"","title":"numerics"},{"location":"references/simulation/#src.simulation.Simulation.log","text":"","title":"log"},{"location":"references/simulation/#src.simulation.Simulation.legacy_compute_lookup_particle_distances","text":"The largest distance distance between two particles is divided into segments provided by Numerics.particle_distance_resolution . This array is then used as a lookup for the caolcuation of the spherical hankel function.","title":"legacy_compute_lookup_particle_distances()"},{"location":"references/simulation/#src.simulation.Simulation.legacy_compute_lookup_particle_distances--notes","text":"This function has been ported from the Matlab Celes framework but is not used by Pyles! Source code in src/simulation.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def legacy_compute_lookup_particle_distances ( self ): \"\"\" The largest distance distance between two particles is divided into segments provided by `Numerics.particle_distance_resolution`. This array is then used as a lookup for the caolcuation of the spherical hankel function. Notes ----- This function has been ported from the Matlab Celes framework but is not used by Pyles! \"\"\" # add two zeros at beginning to allow interpolation # also in the first segment step = self . numerics . particle_distance_resolution maxdist = self . parameters . particles . max_particle_distance + \\ 3 * self . numerics . particle_distance_resolution self . lookup_particle_distances = np . concatenate ( ( np . array ([ 0 ]), np . arange ( 0 , maxdist + np . finfo ( float ) . eps , step )))","title":"Notes"},{"location":"references/simulation/#src.simulation.Simulation.legacy_compute_h3_table","text":"Computes the spherical hankel function at the points calculated in Simulation.legacy_compute_lookup_particle_distances() . Attributes: Name Type Description h3_table np . ndarray Lookup table of the spherical hankel function values at self.lookup_particle_distances","title":"legacy_compute_h3_table()"},{"location":"references/simulation/#src.simulation.Simulation.legacy_compute_h3_table--notes","text":"This function has been ported from the Matlab Celes framework but is not used by Pyles! Source code in src/simulation.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def legacy_compute_h3_table ( self ): \"\"\" Computes the spherical hankel function at the points calculated in [Simulation.legacy_compute_lookup_particle_distances()][src.simulation.Simulation.legacy_compute_lookup_particle_distances]. Attributes ---------- h3_table : np.ndarray Lookup table of the spherical hankel function values at `self.lookup_particle_distances` Notes ----- This function has been ported from the Matlab Celes framework but is not used by Pyles! \"\"\" self . h3_table = np . zeros ( ( 2 * self . numerics . lmax + 1 , self . lookup_particle_distances . shape [ 0 ], self . parameters . medium_mefractive_index . shape [ 0 ]), dtype = complex ) size_param = np . outer ( self . lookup_particle_distances , self . parameters . k_medium ) for p in range ( 2 * self . numerics . lmax + 1 ): self . h3_table [ p , :, :] = \\ spherical_jn ( p , size_param ) + 1 j * \\ spherical_yn ( p , size_param )","title":"Notes"},{"location":"references/simulation/#src.simulation.Simulation.__compute_idx_lookup","text":"Creates a lookup table with the indices using in further calculations. The lookup table is created using compute_idx_lookups . Attributes: Name Type Description idx_lookup np . ndarray Lookup table of the indices to iterate over large arrays.","title":"__compute_idx_lookup()"},{"location":"references/simulation/#src.simulation.Simulation.__compute_idx_lookup--notes","text":"This function uses numba under the hood to speed up the computations. Source code in src/simulation.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 def __compute_idx_lookup ( self ): \"\"\" Creates a lookup table with the indices using in further calculations. The lookup table is created using [compute_idx_lookups][src.functions.cpu_numba.compute_idx_lookups]. Attributes ---------- idx_lookup : np.ndarray Lookup table of the indices to iterate over large arrays. Notes ----- This function uses [numba](https://numba.pydata.org/) under the hood to speed up the computations. \"\"\" self . idx_lookup = compute_idx_lookups ( self . numerics . lmax , self . parameters . particles . number )","title":"Notes"},{"location":"references/simulation/#src.simulation.Simulation.__compute_lookups","text":"Computes various lookup tables for each particle: Spherical Bessel function \\(j_n\\) Spherical Hankel function \\(h_n^{(1)}\\) Associated Legendre polynomial values \\(P_l^m\\) Exponential function value \\(e^{j (m_2-m_1) \\phi}\\) Attributes: Name Type Description sph_j np . ndarray Spherical Bessel function lookup table calculated for pair-wise particles distances sph_h np . ndarray Spherical Hankel function lookup table calculated for pair-wise particles distances plm np . ndarray Associated Legendre polynomial lookup table calculated for the cosine value of the pairwise particle inclination angles e_j_dm_phi np . ndarray Exponential function lookup table calculated for the pairwise particle azimuthal angles","title":"__compute_lookups()"},{"location":"references/simulation/#src.simulation.Simulation.__compute_lookups--notes","text":"This function uses numba under the hood to speed up the computations. Source code in src/simulation.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 def __compute_lookups ( self ): \"\"\" Computes various lookup tables for each particle: - Spherical Bessel function $j_n$ - Spherical Hankel function $h_n^{(1)}$ - Associated Legendre polynomial values $P_l^m$ - Exponential function value $e^{j (m_2-m_1) \\\\phi}$ Attributes ---------- sph_j : np.ndarray Spherical Bessel function lookup table calculated for pair-wise particles distances sph_h : np.ndarray Spherical Hankel function lookup table calculated for pair-wise particles distances plm : np.ndarray Associated Legendre polynomial lookup table calculated for the cosine value of the pairwise particle inclination angles e_j_dm_phi : np.ndarray Exponential function lookup table calculated for the pairwise particle azimuthal angles Notes ----- This function uses [numba](https://numba.pydata.org/) under the hood to speed up the computations. \"\"\" lookup_computation_time_start = time () lmax = self . numerics . lmax particle_number = self . parameters . particles . number dists = squareform ( pdist ( self . parameters . particles . pos )) ct = np . divide ( np . subtract . outer ( self . parameters . particles . pos [:, 2 ], self . parameters . particles . pos [:, 2 ]), dists , out = np . zeros (( particle_number , particle_number )), where = dists != 0 ) phi = np . arctan2 ( np . subtract . outer ( self . parameters . particles . pos [:, 1 ], self . parameters . particles . pos [:, 1 ]), np . subtract . outer ( self . parameters . particles . pos [:, 0 ], self . parameters . particles . pos [:, 0 ])) size_param = np . outer ( dists . ravel (), self . parameters . k_medium ) . reshape ( [ particle_number , particle_number , self . parameters . k_medium . shape [ 0 ]]) self . sph_h = np . zeros (( 2 * lmax + 1 , particle_number , particle_number , self . parameters . k_medium . shape [ 0 ]), dtype = complex ) self . sph_j = np . zeros_like ( self . sph_h ) self . e_j_dm_phi = np . zeros ( ( 4 * lmax + 1 , particle_number , particle_number ), dtype = complex ) self . plm = np . zeros ((( lmax + 1 ) * ( 2 * lmax + 1 ), particle_number , particle_number )) for p in range ( 2 * lmax + 1 ): self . sph_h [ p , :, :, :] = np . sqrt ( np . divide ( np . pi / 2 , size_param , out = np . zeros_like ( size_param ), where = size_param != 0 )) * hankel1 ( p + 1 / 2 , size_param ) self . sph_j [ p , :, :, :] = spherical_jn ( p , size_param ) self . e_j_dm_phi [ p , :, :] = np . exp ( 1 j * ( p - 2 * lmax ) * phi ) self . e_j_dm_phi [ p + 2 * lmax , :, :] = np . exp ( 1 j * p * phi ) for absdm in range ( p + 1 ): cml = np . sqrt (( 2 * p + 1 ) / 2 / np . prod ( np . arange ( p - absdm + 1 , p + absdm + 1 ))) self . plm [ p * ( p + 1 ) // 2 + absdm , :, :] = cml * \\ np . power ( - 1.0 , absdm ) * lpmv ( absdm , p , ct ) self . sph_h = np . nan_to_num ( self . sph_h , nan = 0 ) + np . isnan ( self . sph_h ) * 1 lookup_computation_time_stop = time () self . log . info ( 'Computing lookup tables took %f s' % ( lookup_computation_time_stop - lookup_computation_time_start ))","title":"Notes"},{"location":"references/simulation/#src.simulation.Simulation.__setup","text":"An internal setup function called upon object creation. The following functions are called: __compute_idx_lookups __compute_lookups Source code in src/simulation.py 194 195 196 197 198 199 200 201 202 203 def __setup ( self ): \"\"\" An internal setup function called upon object creation. The following functions are called: - [__compute_idx_lookups][src.simulation.Simulation.__compute_idx_lookup] - [__compute_lookups][src.simulation.Simulation.__compute_lookups] \"\"\" self . __compute_idx_lookup () self . __compute_lookups ()","title":"__setup()"},{"location":"references/simulation/#src.simulation.Simulation.compute_mie_coefficients","text":"Computes the mie coefficients for the unique pair of particle radius and the refractive index of the particle. Attributes: Name Type Description mie_coefficients np . ndarray Mie coefficients table","title":"compute_mie_coefficients()"},{"location":"references/simulation/#src.simulation.Simulation.compute_mie_coefficients--see-also","text":"t_entry : T-Matrix entry function","title":"See Also"},{"location":"references/simulation/#src.simulation.Simulation.compute_mie_coefficients--notes","text":"Due to the four nested loops (particles, tau, l, and m), it could be rewritten using numba to speed the process up. Source code in src/simulation.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 def compute_mie_coefficients ( self ): \"\"\" Computes the mie coefficients for the unique pair of particle radius and the refractive index of the particle. Attributes ---------- mie_coefficients : np.ndarray Mie coefficients table See Also -------- [t_entry][src.functions.t_entry.t_entry] : T-Matrix entry function Notes ----- Due to the four nested loops (particles, tau, l, and m), it could be rewritten using `numba` to speed the process up. \"\"\" self . mie_coefficients = np . zeros ( ( self . parameters . particles . num_unique_pairs , self . numerics . nmax , self . parameters . wavelength . shape [ 0 ]), dtype = complex ) for u_i in range ( self . parameters . particles . num_unique_pairs ): for tau in range ( 1 , 3 ): for l in range ( 1 , self . numerics . lmax + 1 ): for m in range ( - l , l + 1 ): jmult = multi2single_index ( 0 , tau , l , m , self . numerics . lmax ) self . mie_coefficients [ u_i , jmult , :] = t_entry ( tau = tau , l = l , k_medium = self . parameters . k_medium , k_sphere = self . parameters . omega * self . parameters . particles . unique_radius_index_pairs [ u_i , 1 ], radius = np . real ( self . parameters . particles . unique_radius_index_pairs [ u_i , 0 ]))","title":"Notes"},{"location":"references/simulation/#src.simulation.Simulation.compute_initial_field_coefficients","text":"Computes initial field coefficients \\(a_{\\tau ,l,m}\\) and \\(b_{\\tau ,l,m}\\) . Depending on the beam_width , one of two functions is called: __compute_initial_field_coefficients_wavebundle_normal_incidence , \\(\\text{beam width} \\in (0, \\infty)\\) __compute_initial_field_coefficients_planewave , \\(\\text{beam width} = 0\\) or \\(\\text{beam width} = \\infty\\) Attributes: Name Type Description initial_field_coefficients np . ndarray Initial field coefficients Source code in src/simulation.py 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 def compute_initial_field_coefficients ( self ): \"\"\" Computes initial field coefficients $a_{\\\\tau ,l,m}$ and $b_{\\\\tau ,l,m}$. Depending on the `beam_width`, one of two functions is called: - [__compute_initial_field_coefficients_wavebundle_normal_incidence][src.simulation.Simulation.__compute_initial_field_coefficients_wavebundle_normal_incidence], $\\\\text{beam width} \\\\in (0, \\\\infty)$ - [__compute_initial_field_coefficients_planewave][src.simulation.Simulation.__compute_initial_field_coefficients_planewave], $\\\\text{beam width} = 0$ or $\\\\text{beam width} = \\\\infty$ Attributes ---------- initial_field_coefficients : np.ndarray Initial field coefficients \"\"\" self . log . info ( 'compute initial field coefficients ...' ) if np . isfinite ( self . parameters . initial_field . beam_width ) and ( self . parameters . initial_field . beam_width > 0 ): self . log . info ( ' \\t Gaussian beam ...' ) if self . parameters . initial_field . normal_incidence : self . __compute_initial_field_coefficients_wavebundle_normal_incidence () else : self . log . error ( ' \\t this case is not implemented' ) else : self . log . info ( ' \\t plane wave ...' ) self . __compute_initial_field_coefficients_planewave () self . log . info ( 'done' )","title":"compute_initial_field_coefficients()"},{"location":"references/simulation/#src.simulation.Simulation.compute_right_hand_side","text":"The right hand side \\(T \\cdot a_I\\) of the equation \\(M \\cdot b = T \\cdot a_I\\) is computed. Attributes: Name Type Description right_hand_side np . ndarray Right hand side of \\(M \\cdot b = T \\cdot a_I\\)","title":"compute_right_hand_side()"},{"location":"references/simulation/#src.simulation.Simulation.compute_right_hand_side--notes","text":"For more information regarding the equation, please have a look at the paper of Celes . Source code in src/simulation.py 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 def compute_right_hand_side ( self ): \"\"\" The right hand side $T \\\\cdot a_I$ of the equation $M \\\\cdot b = T \\\\cdot a_I$ is computed. Attributes ---------- right_hand_side : np.ndarray Right hand side of $M \\\\cdot b = T \\\\cdot a_I$ Notes ----- For more information regarding the equation, please have a look at the paper of [Celes](https://arxiv.org/abs/1706.02145). \"\"\" self . right_hand_side = self . mie_coefficients [ self . parameters . particles . single_unique_array_idx , :] * self . initial_field_coefficients","title":"Notes"},{"location":"references/simulation/#src.simulation.Simulation.__compute_initial_field_coefficients_planewave","text":"Source code in src/simulation.py 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 def __compute_initial_field_coefficients_planewave ( self ): lmax = self . numerics . lmax E0 = self . parameters . initial_field . amplitude k = self . parameters . k_medium beta = self . parameters . initial_field . polar_angle cb = np . cos ( beta ) sb = np . sin ( beta ) alpha = self . parameters . initial_field . azimuthal_angle # pi and tau symbols for transformation matrix B_dagger pilm , taulm = spherical_functions_trigon ( beta , lmax ) # cylindrical coordinates for relative particle positions relative_particle_positions = self . parameters . particles . pos - \\ self . parameters . initial_field . focal_point kvec = np . outer ( np . array (( sb * np . cos ( alpha ), sb * np . sin ( alpha ), cb )), k ) eikr = np . exp ( 1 j * np . matmul ( relative_particle_positions , kvec )) # clean up some memory? del ( k , beta , cb , sb , kvec , relative_particle_positions ) self . initial_field_coefficients = np . zeros ( ( self . parameters . particles . number , self . numerics . nmax , self . parameters . k_medium . size ), dtype = complex ) for m in range ( - lmax , lmax + 1 ): for tau in range ( 1 , 3 ): for l in range ( np . max ([ 1 , np . abs ( m )]), lmax + 1 ): n = multi2single_index ( 0 , tau , l , m , lmax ) self . initial_field_coefficients [:, n , :] = 4 * E0 * np . exp ( - 1 j * m * alpha ) * eikr * transformation_coefficients ( pilm , taulm , tau , l , m , self . parameters . initial_field . pol , dagger = True )","title":"__compute_initial_field_coefficients_planewave()"},{"location":"references/simulation/#src.simulation.Simulation.__compute_initial_field_coefficients_wavebundle_normal_incidence","text":"","title":"__compute_initial_field_coefficients_wavebundle_normal_incidence()"},{"location":"references/simulation/#src.simulation.Simulation.__compute_initial_field_coefficients_wavebundle_normal_incidence--todo","text":"Implement this function using the celes function initial_field_coefficients_wavebundle_normal_incidence.m Source code in src/simulation.py 317 318 319 320 321 322 323 324 def __compute_initial_field_coefficients_wavebundle_normal_incidence ( self ): \"\"\" TODO ---- Implement this function using the celes function [initial_field_coefficients_wavebundle_normal_incidence.m](https://github.com/disordered-photonics/celes/blob/master/src/initial/initial_field_coefficients_wavebundle_normal_incidence.m) \"\"\" self . initial_field_coefficients = np . zeros ( ( self . parameters . particles . number , self . numerics . nmax , self . parameters . k_medium . size ), dtype = complex ) * np . nan","title":"TODO"},{"location":"references/simulation/#src.simulation.Simulation.coupling_matrix_multiply","text":"Source code in src/simulation.py 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 def coupling_matrix_multiply ( self , x : np . ndarray , idx : int = None ): self . log . info ( 'prepare particle coupling ... ' ) preparation_time = time () lmax = self . numerics . lmax particle_number = self . parameters . particles . number jmax = particle_number * 2 * lmax * ( lmax + 2 ) wavelengths = self . parameters . k_medium . shape [ 0 ] translation_table = self . numerics . translation_ab5 associated_legendre_lookup = self . plm spherical_hankel_lookup = self . sph_h e_j_dm_phi_loopup = self . e_j_dm_phi idx_lookup = self . idx_lookup if idx != None : spherical_hankel_lookup = spherical_hankel_lookup [:, :, :, idx ] spherical_hankel_lookup = np . copy ( spherical_hankel_lookup [:, :, :, np . newaxis ]) wavelengths = 1 self . log . info ( ' \\t Starting Wx computation' ) if self . numerics . gpu : wx_real = np . zeros ( x . shape + ( wavelengths ,), dtype = float ) wx_imag = np . zeros_like ( wx_real ) idx_device = cuda . to_device ( idx_lookup ) x_device = cuda . to_device ( x ) wx_real_device = cuda . to_device ( wx_real ) wx_imag_device = cuda . to_device ( wx_imag ) translation_device = cuda . to_device ( translation_table ) associated_legendre_device = cuda . to_device ( associated_legendre_lookup ) spherical_hankel_device = cuda . to_device ( spherical_hankel_lookup ) e_j_dm_phi_device = cuda . to_device ( e_j_dm_phi_loopup ) threads_per_block = ( 16 , 16 , 2 ) blocks_per_grid_x = ceil ( jmax / threads_per_block [ 0 ]) blocks_per_grid_y = ceil ( jmax / threads_per_block [ 1 ]) blocks_per_grid_z = ceil ( wavelengths / threads_per_block [ 2 ]) blocks_per_grid = ( blocks_per_grid_x , blocks_per_grid_y , blocks_per_grid_z ) coupling_matrix_time = time () particle_interaction_gpu [ blocks_per_grid , threads_per_block ]( lmax , particle_number , idx_device , x_device , wx_real_device , wx_imag_device , translation_device , associated_legendre_device , spherical_hankel_device , e_j_dm_phi_device ) wx_real = wx_real_device . copy_to_host () wx_imag = wx_imag_device . copy_to_host () wx = wx_real + 1 j * wx_imag # particle_interaction.parallel_diagnostics(level=4) time_end = time () self . log . info ( \" \\t Time taken for preparation: %f \" % ( coupling_matrix_time - preparation_time )) self . log . info ( \" \\t Time taken for coupling matrix: %f \" % ( time_end - coupling_matrix_time )) else : # from numba_progress import ProgressBar # num_iterations = jmax * jmax * wavelengths # progress = ProgressBar(total=num_iterations) progress = None wx = particle_interaction ( lmax , particle_number , idx_lookup , x , translation_table , associated_legendre_lookup , spherical_hankel_lookup , e_j_dm_phi_loopup , progress ) time_end = time () self . log . info ( \" \\t Time taken for coupling matrix: %f \" % ( time_end - preparation_time )) if idx != None : wx = np . squeeze ( wx ) return wx","title":"coupling_matrix_multiply()"},{"location":"references/simulation/#src.simulation.Simulation.master_matrix_multiply","text":"Source code in src/simulation.py 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 def master_matrix_multiply ( self , value : np . ndarray , idx : int ): wx = self . coupling_matrix_multiply ( value , idx ) self . log . info ( 'apply T-matrix ...' ) t_matrix_start = time () twx = self . mie_coefficients [ self . parameters . particles . single_unique_array_idx , :, idx ] . ravel ( order = 'C' ) * wx mx = value - twx t_matrix_stop = time () self . log . info ( ' \\t done in %f seconds.' % ( t_matrix_stop - t_matrix_start )) return mx","title":"master_matrix_multiply()"},{"location":"references/simulation/#src.simulation.Simulation.compute_scattered_field_coefficients","text":"Source code in src/simulation.py 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 def compute_scattered_field_coefficients ( self , guess = None ): self . log . info ( 'compute scattered field coefficients ...' ) jmax = self . parameters . particles . number * self . numerics . nmax self . scattered_field_coefficients = np . zeros_like ( self . initial_field_coefficients ) self . scattered_field_err_codes = np . zeros ( self . parameters . wavelengths_number ) if guess is None : guess = self . right_hand_side for w in range ( self . parameters . wavelengths_number ): def mmm ( x ): return self . master_matrix_multiply ( x , w ) A = LinearOperator ( shape = ( jmax , jmax ), matvec = mmm ) b = self . right_hand_side [:, :, w ] . ravel () x0 = guess [:, :, w ] . ravel () self . log . info ( 'Solver run %d / %d ' % ( w + 1 , self . parameters . wavelengths_number )) x , err_code = self . numerics . solver . run ( A , b , x0 ) self . scattered_field_coefficients [:, :, w ] = x . reshape ( self . right_hand_side . shape [: 2 ]) self . scattered_field_err_codes [ w ] = err_code","title":"compute_scattered_field_coefficients()"},{"location":"references/solver/","text":"Solver ( solver_type = 'gmres' , tolerance = 0.0001 , max_iter = 10000.0 , restart = 100.0 ) Source code in src/solver.py 8 9 10 11 12 13 14 def __init__ ( self , solver_type : str = 'gmres' , tolerance : float = 1e-4 , max_iter : int = 1e4 , restart : int = 1e2 ): self . type = solver_type . lower () self . tolerance = tolerance self . max_iter = int ( max_iter ) self . restart = int ( restart ) self . log = logging . getLogger ( __name__ ) type = solver_type . lower () instance-attribute tolerance = tolerance instance-attribute max_iter = int ( max_iter ) instance-attribute restart = int ( restart ) instance-attribute log = logging . getLogger ( __name__ ) instance-attribute run ( a , b , x0 = None ) Source code in src/solver.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def run ( self , a : LinearOperator , b : np . ndarray , x0 : np . ndarray = None ): if x0 is None : x0 = np . copy ( b ) if self . type == 'bicgstab' : counter = GMResCounter ( callback_type = 'x' ) value , err_code = bicgstab ( a , b , x0 , tol = self . tolerance , atol = 0 , maxiter = self . max_iter , callback = counter ) elif self . type == 'gmres' : counter = GMResCounter ( callback_type = 'pr_norm' ) value , err_code = gmres ( a , b , x0 , restart = self . restart , tol = self . tolerance , atol = self . tolerance ** 2 , maxiter = self . max_iter , callback = counter , callback_type = 'pr_norm' ) elif self . type == 'lgmres' : counter = GMResCounter ( callback_type = 'x' ) value , err_code = lgmres ( a , b , x0 , tol = self . tolerance , atol = 0 , maxiter = self . max_iter , callback = counter ) else : self . log . error ( 'Please specify a valid solver type' ) exit ( 1 ) return value , err_code GMResCounter ( disp = False , callback_type = 'pr_norm' ) Bases: object Source code in src/solver.py 40 41 42 43 44 45 46 47 def __init__ ( self , disp = False , callback_type = 'pr_norm' ): self . log = logging . getLogger ( __name__ ) self . _disp = disp self . niter = 0 if callback_type == 'pr_norm' : self . header = ' % 10s \\t % 15s ' % ( 'Iteration' , 'Residual' ) elif callback_type == 'x' : self . header = ' % 10s \\t %s ' % ( 'Iteration' , 'Current Iterate' ) log = logging . getLogger ( __name__ ) instance-attribute niter = 0 instance-attribute header = ' % 10s \\t % 15s ' % ( 'Iteration' , 'Residual' ) instance-attribute __call__ ( rk = None ) Source code in src/solver.py 49 50 51 52 53 54 55 56 57 58 59 60 def __call__ ( self , rk = None ): self . niter += 1 if isinstance ( rk , float ): msg = ' % 10i \\t % 15.5f ' % ( self . niter , rk ) elif isinstance ( rk , np . ndarray ): msg = ' % 10i \\t ' % self . niter + np . array2string ( rk ) self . log . info ( self . header ) self . log . info ( msg ) if self . _disp : print ( self . header ) print ( msg )","title":"Solver"},{"location":"references/solver/#src.solver.Solver","text":"Source code in src/solver.py 8 9 10 11 12 13 14 def __init__ ( self , solver_type : str = 'gmres' , tolerance : float = 1e-4 , max_iter : int = 1e4 , restart : int = 1e2 ): self . type = solver_type . lower () self . tolerance = tolerance self . max_iter = int ( max_iter ) self . restart = int ( restart ) self . log = logging . getLogger ( __name__ )","title":"Solver"},{"location":"references/solver/#src.solver.Solver.type","text":"","title":"type"},{"location":"references/solver/#src.solver.Solver.tolerance","text":"","title":"tolerance"},{"location":"references/solver/#src.solver.Solver.max_iter","text":"","title":"max_iter"},{"location":"references/solver/#src.solver.Solver.restart","text":"","title":"restart"},{"location":"references/solver/#src.solver.Solver.log","text":"","title":"log"},{"location":"references/solver/#src.solver.Solver.run","text":"Source code in src/solver.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def run ( self , a : LinearOperator , b : np . ndarray , x0 : np . ndarray = None ): if x0 is None : x0 = np . copy ( b ) if self . type == 'bicgstab' : counter = GMResCounter ( callback_type = 'x' ) value , err_code = bicgstab ( a , b , x0 , tol = self . tolerance , atol = 0 , maxiter = self . max_iter , callback = counter ) elif self . type == 'gmres' : counter = GMResCounter ( callback_type = 'pr_norm' ) value , err_code = gmres ( a , b , x0 , restart = self . restart , tol = self . tolerance , atol = self . tolerance ** 2 , maxiter = self . max_iter , callback = counter , callback_type = 'pr_norm' ) elif self . type == 'lgmres' : counter = GMResCounter ( callback_type = 'x' ) value , err_code = lgmres ( a , b , x0 , tol = self . tolerance , atol = 0 , maxiter = self . max_iter , callback = counter ) else : self . log . error ( 'Please specify a valid solver type' ) exit ( 1 ) return value , err_code","title":"run()"},{"location":"references/solver/#src.solver.GMResCounter","text":"Bases: object Source code in src/solver.py 40 41 42 43 44 45 46 47 def __init__ ( self , disp = False , callback_type = 'pr_norm' ): self . log = logging . getLogger ( __name__ ) self . _disp = disp self . niter = 0 if callback_type == 'pr_norm' : self . header = ' % 10s \\t % 15s ' % ( 'Iteration' , 'Residual' ) elif callback_type == 'x' : self . header = ' % 10s \\t %s ' % ( 'Iteration' , 'Current Iterate' )","title":"GMResCounter"},{"location":"references/solver/#src.solver.GMResCounter.log","text":"","title":"log"},{"location":"references/solver/#src.solver.GMResCounter.niter","text":"","title":"niter"},{"location":"references/solver/#src.solver.GMResCounter.header","text":"","title":"header"},{"location":"references/solver/#src.solver.GMResCounter.__call__","text":"Source code in src/solver.py 49 50 51 52 53 54 55 56 57 58 59 60 def __call__ ( self , rk = None ): self . niter += 1 if isinstance ( rk , float ): msg = ' % 10i \\t % 15.5f ' % ( self . niter , rk ) elif isinstance ( rk , np . ndarray ): msg = ' % 10i \\t ' % self . niter + np . array2string ( rk ) self . log . info ( self . header ) self . log . info ( msg ) if self . _disp : print ( self . header ) print ( msg )","title":"__call__()"},{"location":"testing/","text":"","title":"Index"},{"location":"testing/coverage/","text":"","title":"Coverage"},{"location":"coverage/","text":".md-content { max-width: none !important; } article h1, article > a { display: none; } var coviframe = document.getElementById(\"coviframe\"); function resizeIframe() { coviframe.style.height = coviframe.contentWindow.document.documentElement.offsetHeight + 'px'; } coviframe.contentWindow.document.body.onclick = function() { coviframe.contentWindow.location.reload(); }","title":"Coverage"}]}